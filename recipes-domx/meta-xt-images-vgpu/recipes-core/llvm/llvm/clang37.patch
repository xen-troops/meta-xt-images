diff --git include/clang/AST/ASTContext.h include/clang/AST/ASTContext.h
index a2bd55a..8472d33 100644
--- a/tools/clang/include/clang/AST/ASTContext.h
+++ b/tools/clang/include/clang/AST/ASTContext.h
@@ -128,6 +128,7 @@ class ASTContext : public RefCountedBase<ASTContext> {
   mutable llvm::FoldingSet<ObjCObjectPointerType> ObjCObjectPointerTypes;
   mutable llvm::FoldingSet<AutoType> AutoTypes;
   mutable llvm::FoldingSet<AtomicType> AtomicTypes;
+  mutable llvm::FoldingSet<PipeType> PipeTypes;
   llvm::FoldingSet<AttributedType> AttributedTypes;
 
   mutable llvm::FoldingSet<QualifiedTemplateName> QualifiedTemplateNames;
@@ -835,9 +836,12 @@ public:
   CanQualType ObjCBuiltinIdTy, ObjCBuiltinClassTy, ObjCBuiltinSelTy;
   CanQualType ObjCBuiltinBoolTy;
   CanQualType OCLImage1dTy, OCLImage1dArrayTy, OCLImage1dBufferTy;
-  CanQualType OCLImage2dTy, OCLImage2dArrayTy;
+  CanQualType OCLImage2dTy, OCLImage2dArrayTy, OCLImage2dDepthTy;
+  CanQualType OCLImage2dArrayDepthTy, OCLImage2dMSAATy, OCLImage2dArrayMSAATy;
+  CanQualType OCLImage2dMSAADepthTy, OCLImage2dArrayMSAADepthTy;
   CanQualType OCLImage3dTy;
-  CanQualType OCLSamplerTy, OCLEventTy;
+  CanQualType OCLSamplerTy, OCLEventTy, OCLClkEventTy;
+  CanQualType OCLQueueTy, OCLNDRangeTy, OCLReserveIDTy;
 
   // Types for deductions in C++0x [stmt.ranged]'s desugaring. Built on demand.
   mutable QualType AutoDeductTy;     // Deduction against 'auto'.
@@ -997,6 +1001,7 @@ public:
   /// \brief Return the uniqued reference to the atomic type for the specified
   /// type.
   QualType getAtomicType(QualType T) const;
+  QualType getPipeType(QualType T) const;
 
   /// \brief Return the uniqued reference to the type for a block of the
   /// specified type.
diff --git include/clang/AST/BuiltinTypes.def include/clang/AST/BuiltinTypes.def
index 488cace..3680cae 100644
--- a/tools/clang/include/clang/AST/BuiltinTypes.def
+++ b/tools/clang/include/clang/AST/BuiltinTypes.def
@@ -160,6 +160,12 @@ BUILTIN_TYPE(OCLImage1dArray, OCLImage1dArrayTy)
 BUILTIN_TYPE(OCLImage1dBuffer, OCLImage1dBufferTy)
 BUILTIN_TYPE(OCLImage2d, OCLImage2dTy)
 BUILTIN_TYPE(OCLImage2dArray, OCLImage2dArrayTy)
+BUILTIN_TYPE(OCLImage2dDepth, OCLImage2dDepthTy)
+BUILTIN_TYPE(OCLImage2dArrayDepth, OCLImage2dArrayDepthTy)
+BUILTIN_TYPE(OCLImage2dMSAA, OCLImage2dMSAATy)
+BUILTIN_TYPE(OCLImage2dArrayMSAA, OCLImage2dArrayMSAATy)
+BUILTIN_TYPE(OCLImage2dMSAADepth, OCLImage2dMSAADepthTy)
+BUILTIN_TYPE(OCLImage2dArrayMSAADepth, OCLImage2dArrayMSAADepthTy)
 BUILTIN_TYPE(OCLImage3d, OCLImage3dTy)
 
 // OpenCL sampler_t.
@@ -168,6 +174,18 @@ BUILTIN_TYPE(OCLSampler, OCLSamplerTy)
 // OpenCL event_t.
 BUILTIN_TYPE(OCLEvent, OCLEventTy)
 
+// OpenCL clk_event_t.
+BUILTIN_TYPE(OCLClkEvent, OCLClkEventTy)
+
+// OpenCL queue_t.
+BUILTIN_TYPE(OCLQueue, OCLQueueTy)
+
+// OpenCL ndrange_t.
+BUILTIN_TYPE(OCLNDRange, OCLNDRangeTy)
+
+// OpenCL reserve_id_t.
+BUILTIN_TYPE(OCLReserveID, OCLReserveIDTy)
+
 // This represents the type of an expression whose type is
 // totally unknown, e.g. 'T::foo'.  It is permitted for this to
 // appear in situations where the structure of the type is
diff --git include/clang/AST/DataRecursiveASTVisitor.h include/clang/AST/DataRecursiveASTVisitor.h
index dd167fe..d35caf6 100644
--- a/tools/clang/include/clang/AST/DataRecursiveASTVisitor.h
+++ b/tools/clang/include/clang/AST/DataRecursiveASTVisitor.h
@@ -949,6 +949,7 @@ DEF_TRAVERSE_TYPE(ObjCObjectPointerType,
                   { TRY_TO(TraverseType(T->getPointeeType())); })
 
 DEF_TRAVERSE_TYPE(AtomicType, { TRY_TO(TraverseType(T->getValueType())); })
+DEF_TRAVERSE_TYPE(PipeType, { TRY_TO(TraverseType(T->getValueType())); })
 
 #undef DEF_TRAVERSE_TYPE
 
@@ -1177,6 +1178,7 @@ DEF_TRAVERSE_TYPELOC(ObjCObjectPointerType,
                      { TRY_TO(TraverseTypeLoc(TL.getPointeeLoc())); })
 
 DEF_TRAVERSE_TYPELOC(AtomicType, { TRY_TO(TraverseTypeLoc(TL.getValueLoc())); })
+DEF_TRAVERSE_TYPELOC(PipeType, { TRY_TO(TraverseTypeLoc(TL.getValueLoc())); })
 
 #undef DEF_TRAVERSE_TYPELOC
 
diff --git include/clang/AST/Decl.h include/clang/AST/Decl.h
index e06b58b..5e5bdf4 100644
--- a/tools/clang/include/clang/AST/Decl.h
+++ b/tools/clang/include/clang/AST/Decl.h
@@ -1649,7 +1649,7 @@ protected:
       redeclarable_base(C),
       ParamInfo(nullptr), Body(),
       SClass(S),
-      IsInline(isInlineSpecified), IsInlineSpecified(isInlineSpecified),
+      IsInline(false), IsInlineSpecified(isInlineSpecified),
       IsVirtualAsWritten(false), IsPure(false), HasInheritedPrototype(false),
       HasWrittenPrototype(true), IsDeleted(false), IsTrivial(false),
       IsDefaulted(false), IsExplicitlyDefaulted(false),
diff --git include/clang/AST/RecursiveASTVisitor.h include/clang/AST/RecursiveASTVisitor.h
index 1017656..bd09134 100644
--- a/tools/clang/include/clang/AST/RecursiveASTVisitor.h
+++ b/tools/clang/include/clang/AST/RecursiveASTVisitor.h
@@ -1017,6 +1017,7 @@ DEF_TRAVERSE_TYPE(ObjCObjectPointerType,
                   { TRY_TO(TraverseType(T->getPointeeType())); })
 
 DEF_TRAVERSE_TYPE(AtomicType, { TRY_TO(TraverseType(T->getValueType())); })
+DEF_TRAVERSE_TYPE(PipeType, { TRY_TO(TraverseType(T->getValueType())); })
 
 #undef DEF_TRAVERSE_TYPE
 
@@ -1245,6 +1246,7 @@ DEF_TRAVERSE_TYPELOC(ObjCObjectPointerType,
                      { TRY_TO(TraverseTypeLoc(TL.getPointeeLoc())); })
 
 DEF_TRAVERSE_TYPELOC(AtomicType, { TRY_TO(TraverseTypeLoc(TL.getValueLoc())); })
+DEF_TRAVERSE_TYPELOC(PipeType, { TRY_TO(TraverseTypeLoc(TL.getValueLoc())); })
 
 #undef DEF_TRAVERSE_TYPELOC
 
diff --git include/clang/AST/Type.h include/clang/AST/Type.h
index 632d4b9..6fb82a6 100644
--- a/tools/clang/include/clang/AST/Type.h
+++ b/tools/clang/include/clang/AST/Type.h
@@ -415,7 +415,11 @@ public:
         // Otherwise in OpenCLC v2.0 s6.5.5: every address space except
         // for __constant can be used as __generic.
         (getAddressSpace() == LangAS::opencl_generic &&
-         other.getAddressSpace() != LangAS::opencl_constant);
+         other.getAddressSpace() != LangAS::opencl_constant) ||
+        (getAddressSpace() == 0 &&
+         other.getAddressSpace() == LangAS::opencl_private)||
+        (getAddressSpace() == LangAS::opencl_private &&
+         other.getAddressSpace() == 0);
   }
 
   /// \brief Determines if these qualifiers compatibly include another set.
@@ -1684,18 +1688,29 @@ public:
   bool isTemplateTypeParmType() const;          // C++ template type parameter
   bool isNullPtrType() const;                   // C++0x nullptr_t
   bool isAtomicType() const;                    // C11 _Atomic()
+  bool isPipeType() const;                    // OpenCL pipe
 
   bool isImage1dT() const;                      // OpenCL image1d_t
   bool isImage1dArrayT() const;                 // OpenCL image1d_array_t
   bool isImage1dBufferT() const;                // OpenCL image1d_buffer_t
   bool isImage2dT() const;                      // OpenCL image2d_t
   bool isImage2dArrayT() const;                 // OpenCL image2d_array_t
+  bool isImage2dDepthT() const;                 // Opencl image_2d_depth_t
+  bool isImage2dArrayDepthT() const;            // Opencl image_2d_array_depth_t
+  bool isImage2dMSAAT() const;                  // Opencl image_2d_msaa_t
+  bool isImage2dArrayMSAAT() const;             // Opencl image_2d_array_msaa_t
+  bool isImage2dMSAATDepth() const;             // Opencl image_2d_msaa_depth_t
+  bool isImage2dArrayMSAATDepth() const;        // Opencl image_2d_array_msaa_depth_t
   bool isImage3dT() const;                      // OpenCL image3d_t
 
   bool isImageType() const;                     // Any OpenCL image type
 
   bool isSamplerT() const;                      // OpenCL sampler_t
   bool isEventT() const;                        // OpenCL event_t
+  bool isClkEventT() const;                     // OpenCL clk_event_t
+  bool isQueueT() const;                        // OpenCL queue_t
+  bool isNDRangeT() const;                      // OpenCL ndrange_t
+  bool isReserveIDT() const;                    // OpenCL reserve_id_t
 
   bool isOpenCLSpecificType() const;            // Any OpenCL specific type
 
@@ -4978,6 +4993,37 @@ class AtomicType : public Type, public llvm::FoldingSetNode {
   }
 };
 
+class PipeType : public Type, public llvm::FoldingSetNode {
+  QualType ValueType;
+
+  PipeType(QualType ValTy, QualType Canonical)
+    : Type(Pipe, Canonical, ValTy->isDependentType(),
+           ValTy->isInstantiationDependentType(),
+           ValTy->isVariablyModifiedType(),
+           ValTy->containsUnexpandedParameterPack()),
+      ValueType(ValTy) {}
+  friend class ASTContext;  // ASTContext creates these.
+
+  public:
+  /// getValueType - Gets the type contained by this pipe type, i.e.
+  /// the type returned by performing a read of the pipe.
+  QualType getValueType() const { return ValueType; }
+
+  bool isSugared() const { return false; }
+  QualType desugar() const { return QualType(this, 0); }
+
+  void Profile(llvm::FoldingSetNodeID &ID) {
+    Profile(ID, getValueType());
+  }
+  static void Profile(llvm::FoldingSetNodeID &ID, QualType T) {
+    ID.AddPointer(T.getAsOpaquePtr());
+  }
+  static bool classof(const Type *T) {
+    return T->getTypeClass() == Pipe;
+  }
+};
+
+
 /// A qualifier set is used to build a set of qualifiers.
 class QualifierCollector : public Qualifiers {
 public:
@@ -5314,6 +5360,9 @@ inline bool Type::isObjCObjectOrInterfaceType() const {
 inline bool Type::isAtomicType() const {
   return isa<AtomicType>(CanonicalType);
 }
+inline bool Type::isPipeType() const {
+  return isa<PipeType>(CanonicalType);
+}
 
 inline bool Type::isObjCQualifiedIdType() const {
   if (const ObjCObjectPointerType *OPT = getAs<ObjCObjectPointerType>())
@@ -5364,6 +5413,30 @@ inline bool Type::isImage2dArrayT() const {
   return isSpecificBuiltinType(BuiltinType::OCLImage2dArray);
 }
 
+inline bool Type::isImage2dDepthT() const {
+  return isSpecificBuiltinType(BuiltinType::OCLImage2dDepth);
+}
+
+inline bool Type::isImage2dArrayDepthT() const {
+  return isSpecificBuiltinType(BuiltinType::OCLImage2dArrayDepth);
+}
+
+inline bool Type::isImage2dMSAAT() const {
+  return isSpecificBuiltinType(BuiltinType::OCLImage2dMSAA);
+}
+
+inline bool Type::isImage2dArrayMSAAT() const {
+  return isSpecificBuiltinType(BuiltinType::OCLImage2dArrayMSAA);
+}
+
+inline bool Type::isImage2dMSAATDepth() const {
+  return isSpecificBuiltinType(BuiltinType::OCLImage2dMSAADepth);
+}
+
+inline bool Type::isImage2dArrayMSAATDepth() const {
+  return isSpecificBuiltinType(BuiltinType::OCLImage2dArrayMSAADepth);
+}
+
 inline bool Type::isImage3dT() const {
   return isSpecificBuiltinType(BuiltinType::OCLImage3d);
 }
@@ -5376,14 +5449,35 @@ inline bool Type::isEventT() const {
   return isSpecificBuiltinType(BuiltinType::OCLEvent);
 }
 
+inline bool Type::isClkEventT() const {
+  return isSpecificBuiltinType(BuiltinType::OCLClkEvent);
+}
+
+inline bool Type::isQueueT() const {
+  return isSpecificBuiltinType(BuiltinType::OCLQueue);
+}
+
+inline bool Type::isNDRangeT() const {
+  return isSpecificBuiltinType(BuiltinType::OCLNDRange);
+}
+
+inline bool Type::isReserveIDT() const {
+  return isSpecificBuiltinType(BuiltinType::OCLReserveID);
+}
+
 inline bool Type::isImageType() const {
   return isImage3dT() ||
-         isImage2dT() || isImage2dArrayT() ||
+         isImage2dT() || isImage2dArrayT() || isImage2dDepthT() ||
+         isImage2dArrayDepthT() || isImage2dMSAAT() ||
+         isImage2dArrayMSAAT() || isImage2dMSAATDepth() ||
+         isImage2dArrayMSAATDepth() ||
          isImage1dT() || isImage1dArrayT() || isImage1dBufferT();
 }
 
 inline bool Type::isOpenCLSpecificType() const {
-  return isSamplerT() || isEventT() || isImageType();
+  return isSamplerT() || isEventT() || isImageType() ||
+         isClkEventT() || isQueueT() || isNDRangeT() ||
+         isReserveIDT();
 }
 
 inline bool Type::isTemplateTypeParmType() const {
diff --git include/clang/AST/TypeLoc.h include/clang/AST/TypeLoc.h
index f4d20b8..ac26a33 100644
--- a/tools/clang/include/clang/AST/TypeLoc.h
+++ b/tools/clang/include/clang/AST/TypeLoc.h
@@ -1970,6 +1970,10 @@ struct AtomicTypeLocInfo {
   SourceLocation KWLoc, LParenLoc, RParenLoc;
 };
 
+struct PipeTypeLocInfo {
+  SourceLocation KWLoc, LParenLoc, RParenLoc;
+};
+
 class AtomicTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc, AtomicTypeLoc,
                                              AtomicType, AtomicTypeLocInfo> {
 public:
@@ -2022,6 +2026,58 @@ public:
 };
 
 
+class PipeTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc, PipeTypeLoc,
+                                             PipeType, PipeTypeLocInfo> {
+public:
+  TypeLoc getValueLoc() const {
+    return this->getInnerTypeLoc();
+  }
+
+  SourceRange getLocalSourceRange() const {
+    return SourceRange(getKWLoc(), getRParenLoc());
+  }
+
+  SourceLocation getKWLoc() const {
+    return this->getLocalData()->KWLoc;
+  }
+  void setKWLoc(SourceLocation Loc) {
+    this->getLocalData()->KWLoc = Loc;
+  }
+
+  SourceLocation getLParenLoc() const {
+    return this->getLocalData()->LParenLoc;
+  }
+  void setLParenLoc(SourceLocation Loc) {
+    this->getLocalData()->LParenLoc = Loc;
+  }
+
+  SourceLocation getRParenLoc() const {
+    return this->getLocalData()->RParenLoc;
+  }
+  void setRParenLoc(SourceLocation Loc) {
+    this->getLocalData()->RParenLoc = Loc;
+  }
+
+  SourceRange getParensRange() const {
+    return SourceRange(getLParenLoc(), getRParenLoc());
+  }
+  void setParensRange(SourceRange Range) {
+    setLParenLoc(Range.getBegin());
+    setRParenLoc(Range.getEnd());
+  }
+
+  void initializeLocal(ASTContext &Context, SourceLocation Loc) {
+    setKWLoc(Loc);
+    setLParenLoc(Loc);
+    setRParenLoc(Loc);
+  }
+
+  QualType getInnerType() const {
+    return this->getTypePtr()->getValueType();
+  }
+};
+
+
 }
 
 #endif
diff --git include/clang/AST/TypeNodes.def include/clang/AST/TypeNodes.def
index 2549f0b..bffbeaa 100644
--- a/tools/clang/include/clang/AST/TypeNodes.def
+++ b/tools/clang/include/clang/AST/TypeNodes.def
@@ -105,9 +105,10 @@ TYPE(ObjCObject, Type)
 TYPE(ObjCInterface, ObjCObjectType)
 TYPE(ObjCObjectPointer, Type)
 TYPE(Atomic, Type)
+TYPE(Pipe, Type)
 
 #ifdef LAST_TYPE
-LAST_TYPE(Atomic)
+LAST_TYPE(Pipe)
 #undef LAST_TYPE
 #endif
 
diff --git include/clang/ASTMatchers/ASTMatchers.h include/clang/ASTMatchers/ASTMatchers.h
index 281d637..89744f0 100644
--- a/tools/clang/include/clang/ASTMatchers/ASTMatchers.h
+++ b/tools/clang/include/clang/ASTMatchers/ASTMatchers.h
@@ -3568,6 +3568,16 @@ AST_MATCHER_P(VariableArrayType, hasSizeExpr,
 ///   matches "_Atomic(int) i"
 AST_TYPE_MATCHER(AtomicType, atomicType);
 
+/// \brief Matches pipe types.
+///
+/// Given
+/// \code
+///   pipe(int) i;
+/// \endcode
+/// pipeType()
+///   matches "pipe(int) i"
+AST_TYPE_MATCHER(PipeType, pipeType);
+
 /// \brief Matches atomic types with a specific value type.
 ///
 /// Given
diff --git include/clang/Basic/AddressSpaces.h include/clang/Basic/AddressSpaces.h
index 8dd7566..79a04f3 100644
--- a/tools/clang/include/clang/Basic/AddressSpaces.h
+++ b/tools/clang/include/clang/Basic/AddressSpaces.h
@@ -31,6 +31,7 @@ enum ID {
   opencl_local,
   opencl_constant,
   opencl_generic,
+  opencl_private,
 
   cuda_device,
   cuda_constant,
diff --git include/clang/Basic/Attr.td include/clang/Basic/Attr.td
index 6187bcb..f370ac0 100644
--- a/tools/clang/include/clang/Basic/Attr.td
+++ b/tools/clang/include/clang/Basic/Attr.td
@@ -619,13 +619,19 @@ def OpenCLKernel : InheritableAttr {
   let Documentation = [Undocumented];
 }
 
+def OpenCLUnrollHint : InheritableAttr {
+  let Spellings = [GNU<"opencl_unroll_hint">];
+  let Args = [UnsignedArgument<"UnrollHint">];
+  let Documentation = [OpenCLUnrollHintDocs];
+}
+
 // This attribute is both a type attribute, and a declaration attribute (for
 // parameter variables).
 def OpenCLImageAccess : Attr {
   let Spellings = [Keyword<"__read_only">, Keyword<"read_only">,
                    Keyword<"__write_only">, Keyword<"write_only">,
                    Keyword<"__read_write">, Keyword<"read_write">];
-  let Subjects = SubjectList<[ParmVar], ErrorDiag>;
+//  let Subjects = SubjectList<[ParmVar], ErrorDiag>;
   let Accessors = [Accessor<"isReadOnly", [Keyword<"__read_only">,
                                            Keyword<"read_only">]>,
                    Accessor<"isReadWrite", [Keyword<"__read_write">,
diff --git include/clang/Basic/AttrDocs.td include/clang/Basic/AttrDocs.td
index 4866016..ae04662 100644
--- a/tools/clang/include/clang/Basic/AttrDocs.td
+++ b/tools/clang/include/clang/Basic/AttrDocs.td
@@ -1415,6 +1415,19 @@ for further details including limitations of the unroll hints.
   }];
 }
 
+def OpenCLUnrollHintDocs : Documentation {
+  let Category = DocCatStmt;
+  let Heading = "__attribute__((opencl_unroll_hint))";
+  let Content = [{
+The opencl_unroll_hint attribute qualifier can be used to specify that a loop
+(for, while and do loops) can be unrolled. This attribute qualifier can be
+used to specify full unrolling or partial unrolling by a specified amount.
+This is a compiler hint and the compiler may ignore this directive. See
+`OpenCL v2.0 <https://www.khronos.org/registry/cl/specs/opencl-2.0.pdf>`_
+s6.11.5 for details.
+  }];
+}
+
 def DocOpenCLAddressSpaces : DocumentationCategory<"OpenCL Address Spaces"> {
   let Content = [{
 The address space qualifier may be used to specify the region of memory that is
diff --git include/clang/Basic/DiagnosticParseKinds.td include/clang/Basic/DiagnosticParseKinds.td
index e4f8599..eee470b 100644
--- a/tools/clang/include/clang/Basic/DiagnosticParseKinds.td
+++ b/tools/clang/include/clang/Basic/DiagnosticParseKinds.td
@@ -51,6 +51,9 @@ def warn_extra_semi_after_mem_fn_def : Warning<
   "extra ';' after member function definition">,
   InGroup<ExtraSemi>, DefaultIgnore;
 
+def error_ext_opencl_pragma_unsupported :
+  Error<"unsupported OpenCL extension.">;
+
 def ext_duplicate_declspec : ExtWarn<"duplicate '%0' declaration specifier">,
   InGroup<DuplicateDeclSpecifier>;
 def warn_duplicate_declspec : Warning<"duplicate '%0' declaration specifier">,
@@ -965,6 +968,9 @@ def err_pragma_optimize_extra_argument : Error<
 def err_opencl_unknown_type_specifier : Error<
   "OpenCL does not support the '%0' %select{type qualifier|storage class specifier}1">;
 
+def err_opencl_unroll_hint_on_non_loop : Error<
+  "OpenCL only supports 'opencl_unroll_hint' attribute on for, while, and do statements">;
+
 // OpenCL EXTENSION pragma (OpenCL 1.1 [9.1])
 def warn_pragma_expected_colon : Warning<
   "missing ':' after %0 - ignoring">, InGroup<IgnoredPragmas>;
diff --git include/clang/Basic/DiagnosticSemaKinds.td include/clang/Basic/DiagnosticSemaKinds.td
index 82f5121..1c78697 100644
--- a/tools/clang/include/clang/Basic/DiagnosticSemaKinds.td
+++ b/tools/clang/include/clang/Basic/DiagnosticSemaKinds.td
@@ -269,6 +269,9 @@ def ext_implicit_function_decl : ExtWarn<
   InGroup<ImplicitFunctionDeclare>;
 def note_function_suggestion : Note<"did you mean %0?">;
 
+def err_implicit_function_decl : Error<
+  "implicit declaration of function %0 is invalid in OpenCL">;
+
 def err_ellipsis_first_param : Error<
   "ISO C requires a named parameter before '...'">;
 def err_declarator_need_ident : Error<"declarator requires an identifier">;
@@ -1988,6 +1991,10 @@ def err_attribute_too_few_arguments : Error<
 def err_attribute_invalid_vector_type : Error<"invalid vector element type %0">;
 def err_attribute_bad_neon_vector_size : Error<
   "Neon vector size must be 64 or 128 bits">;
+def err_attribute_requires_positive_integer : Error<
+  "%0 attribute requires a positive integral compile time constant expression">;
+def err_attribute_requires_opencl_version : Error<
+  "%0 attribute requires OpenCL version %1 or above">;
 def warn_unsupported_target_attribute
     : Warning<"Ignoring unsupported '%0' in the target attribute string">,
     InGroup<IgnoredAttributes>;
@@ -4704,8 +4711,12 @@ def err_func_def_incomplete_result : Error<
   "incomplete result type %0 in function definition">;
 def err_atomic_specifier_bad_type : Error<
   "_Atomic cannot be applied to "
-  "%select{incomplete |array |function |reference |atomic |qualified |}0type "
-  "%1 %select{||||||which is not trivially copyable}0">;
+  "%select{incomplete |array |function |reference |atomic |pipe |qualified |}0type "
+  "%1 %select{|||||||which is not trivially copyable}0">;
+def err_pipe_specifier_bad_type : Error<
+  "pipe cannot be applied to "
+  "%select{incomplete |array |function |reference |atomic |pipe |qualified |}0type "
+  "%1 %select{|||||||which is not trivially copyable}0">;
 
 // Expressions.
 def ext_sizeof_alignof_function_type : Extension<
@@ -6939,8 +6950,8 @@ def err_generic_sel_multi_match : Error<
 
 
 // Blocks
-def err_blocks_disable : Error<"blocks support disabled - compile with -fblocks"
-  " or pick a deployment target that supports them">;
+def err_blocks_disable : Error<"blocks is a CL2.0 feature -"
+  " compile with -cl-std=CL2.0">;
 def err_block_returning_array_function : Error<
   "block cannot return %select{array|function}0 type %1">;
 
@@ -7415,6 +7426,8 @@ def err_wrong_sampler_addressspace: Error<
   "sampler type cannot be used with the __local and __global address space qualifiers">;
 def err_opencl_global_invalid_addr_space : Error<
   "global variables must have a constant address space qualifier">;
+def err_opencl_global_invalid_addr_space200 : Error<
+  "global variables must have a constant or global address space qualifier">;
 def err_opencl_no_main : Error<"%select{function|kernel}0 cannot be called 'main'">;
 def err_opencl_kernel_attr :
   Error<"attribute %0 can only be applied to a kernel function">;
diff --git include/clang/Basic/LangOptions.def include/clang/Basic/LangOptions.def
index c184df7..e21963a 100644
--- a/tools/clang/include/clang/Basic/LangOptions.def
+++ b/tools/clang/include/clang/Basic/LangOptions.def
@@ -183,8 +183,13 @@ BENIGN_LANGOPT(DebuggerObjCLiteral , 1, 0, "debugger Objective-C literals and su
 
 BENIGN_LANGOPT(SpellChecking , 1, 1, "spell-checking")
 LANGOPT(SinglePrecisionConstants , 1, 0, "treating double-precision floating point constants as single precision constants")
+LANGOPT(FloatConstRoundToZero , 1, 0, "floating point constants get parsed in round-towards-zero mode")
 LANGOPT(FastRelaxedMath , 1, 0, "OpenCL fast relaxed math")
 LANGOPT(DefaultFPContract , 1, 0, "FP_CONTRACT")
+LANGOPT(DenormsAreZero , 1, 0, "OpenCL denorms are zero")
+LANGOPT(StrictAliasing , 1, 0, "OpenCL strict aliasing")
+LANGOPT(NoSignedZeros , 1, 0, "OpenCL no signed zeros")
+LANGOPT(DisableFPContract , 1, 0, "Set if FP_CONTRACT has been set to false")
 LANGOPT(NoBitFieldTypeAlign , 1, 0, "bit-field type alignment")
 LANGOPT(HexagonQdsp6Compat , 1, 0, "hexagon-qdsp6 backward compatibility")
 LANGOPT(ObjCAutoRefCount , 1, 0, "Objective-C automated reference counting")
diff --git include/clang/Basic/OpenCLExtensions.def include/clang/Basic/OpenCLExtensions.def
index 103fa83..8f1ae0c 100644
--- a/tools/clang/include/clang/Basic/OpenCLExtensions.def
+++ b/tools/clang/include/clang/Basic/OpenCLExtensions.def
@@ -25,6 +25,7 @@ OPENCLEXT(cl_khr_local_int32_base_atomics)
 OPENCLEXT(cl_khr_local_int32_extended_atomics)
 OPENCLEXT(cl_khr_byte_addressable_store)
 OPENCLEXT(cl_khr_3d_image_writes)
+OPENCLEXT(cles_khr_int64)
 
 // Clang Extensions.
 OPENCLEXT(cl_clang_storage_class_specifiers)
diff --git include/clang/Basic/Specifiers.h include/clang/Basic/Specifiers.h
index d95a77f..eba0ab5 100644
--- a/tools/clang/include/clang/Basic/Specifiers.h
+++ b/tools/clang/include/clang/Basic/Specifiers.h
@@ -66,6 +66,7 @@ namespace clang {
     TST_decltype_auto,    // C++1y decltype(auto)
     TST_unknown_anytype,  // __unknown_anytype extension
     TST_atomic,           // C11 _Atomic
+    TST_pipe,           // OpenCL pipe
     TST_error         // erroneous type
   };
   
diff --git include/clang/Basic/TokenKinds.def include/clang/Basic/TokenKinds.def
index 8333a4c..f85a1e9 100644
--- a/tools/clang/include/clang/Basic/TokenKinds.def
+++ b/tools/clang/include/clang/Basic/TokenKinds.def
@@ -501,6 +501,7 @@ KEYWORD(__read_write                , KEYOPENCL)
 ALIAS("read_only", __read_only      , KEYOPENCL)
 ALIAS("write_only", __write_only    , KEYOPENCL)
 ALIAS("read_write", __read_write    , KEYOPENCL)
+KEYWORD(pipe                        , KEYOPENCL)
 // OpenCL builtins
 KEYWORD(__builtin_astype            , KEYOPENCL)
 KEYWORD(vec_step                    , KEYOPENCL|KEYALTIVEC|KEYZVECTOR)
diff --git include/clang/Driver/CC1Options.td include/clang/Driver/CC1Options.td
index d2f0d05..37029cd 100644
--- a/tools/clang/include/clang/Driver/CC1Options.td
+++ b/tools/clang/include/clang/Driver/CC1Options.td
@@ -623,6 +623,8 @@ def cl_finite_math_only : Flag<["-"], "cl-finite-math-only">,
   HelpText<"OpenCL only. Allow floating-point optimizations that assume arguments and results are not NaNs or +-Inf.">;
 def cl_kernel_arg_info : Flag<["-"], "cl-kernel-arg-info">,
   HelpText<"OpenCL only. Generate kernel argument metadata.">;
+def : Flag<["-"], "cl-no-signed-zeros">, Alias<fno_signed_zeros>,
+  HelpText<"OpenCL only. Allow optimizations to ignore the signedness of the floating-point zero.">;
 def cl_unsafe_math_optimizations : Flag<["-"], "cl-unsafe-math-optimizations">,
   HelpText<"OpenCL only. Allow unsafe floating-point optimizations.  Also implies -cl-no-signed-zeros and -cl-mad-enable">;
 def cl_fast_relaxed_math : Flag<["-"], "cl-fast-relaxed-math">,
@@ -632,7 +634,9 @@ def cl_mad_enable : Flag<["-"], "cl-mad-enable">,
 def cl_std_EQ : Joined<["-"], "cl-std=">,
   HelpText<"OpenCL language standard to compile for">;
 def cl_denorms_are_zero : Flag<["-"], "cl-denorms-are-zero">,
-  HelpText<"OpenCL only. Allow denormals to be flushed to zero">;
+  HelpText<"OpenCL only. Allow flushing denormal values to zero.">;
+def cl_create_library  : Flag<["-"], "create-library">,
+  HelpText<"OpenCL only. Create an OpenCL library.">;
 
 //===----------------------------------------------------------------------===//
 // CUDA Options
diff --git include/clang/Frontend/CompilerInstance.h include/clang/Frontend/CompilerInstance.h
index 45e5ed1..12bdd21 100644
--- a/tools/clang/include/clang/Frontend/CompilerInstance.h
+++ b/tools/clang/include/clang/Frontend/CompilerInstance.h
@@ -638,7 +638,8 @@ public:
 
   /// Create an external AST source to read a PCH file and attach it to the AST
   /// context.
-  void createPCHExternalASTSource(StringRef Path, bool DisablePCHValidation,
+  void createPCHExternalASTSource(StringRef Path, llvm::MemoryBuffer *MB,
+                                  bool DisablePCHValidation,
                                   bool AllowPCHWithCompilerErrors,
                                   void *DeserializationListener,
                                   bool OwnDeserializationListener);
@@ -647,7 +648,8 @@ public:
   ///
   /// \return - The new object on success, or null on failure.
   static IntrusiveRefCntPtr<ASTReader> createPCHExternalASTSource(
-      StringRef Path, StringRef Sysroot, bool DisablePCHValidation,
+      StringRef Path, const std::string &Sysroot, llvm::MemoryBuffer *MB, 
+      bool DisablePCHValidation,
       bool AllowPCHWithCompilerErrors, Preprocessor &PP, ASTContext &Context,
       const PCHContainerReader &PCHContainerRdr,
       void *DeserializationListener, bool OwnDeserializationListener,
diff --git include/clang/Lex/LiteralSupport.h include/clang/Lex/LiteralSupport.h
index 5210e3f..ded7c72 100644
--- a/tools/clang/include/clang/Lex/LiteralSupport.h
+++ b/tools/clang/include/clang/Lex/LiteralSupport.h
@@ -49,6 +49,9 @@ class NumericLiteralParser {
 
   unsigned radix;
 
+  /// Rounding mode for float parsing.
+  llvm::APFloat::roundingMode Rounding;
+
   bool saw_exponent, saw_period, saw_ud_suffix;
 
   SmallString<32> UDSuffixBuf;
@@ -56,14 +59,16 @@ class NumericLiteralParser {
 public:
   NumericLiteralParser(StringRef TokSpelling,
                        SourceLocation TokLoc,
-                       Preprocessor &PP);
+                       Preprocessor &PP,
+                       llvm::APFloat::roundingMode Rounding = llvm::APFloat::rmNearestTiesToEven);
   bool hadError : 1;
   bool isUnsigned : 1;
-  bool isLong : 1;          // This is *not* set for long long.
+  bool isLong : 1;        // This is *not* set for long long.
   bool isLongLong : 1;
-  bool isFloat : 1;         // 1.0f
-  bool isImaginary : 1;     // 1.0i
-  uint8_t MicrosoftInteger; // Microsoft suffix extension i8, i16, i32, or i64.
+  bool isHalf : 1;        // 1.0h
+  bool isFloat : 1;       // 1.0f
+  bool isImaginary : 1;   // 1.0i
+  uint8_t MicrosoftInteger;  // Microsoft suffix extension i8, i16, i32, or i64.
 
   bool isIntegerLiteral() const {
     return !saw_period && !saw_exponent;
diff --git include/clang/Lex/Preprocessor.h include/clang/Lex/Preprocessor.h
index b2f58ea..0688640 100644
--- a/tools/clang/include/clang/Lex/Preprocessor.h
+++ b/tools/clang/include/clang/Lex/Preprocessor.h
@@ -677,6 +677,7 @@ public:
   void setDiagnostics(DiagnosticsEngine &D) { Diags = &D; }
 
   const LangOptions &getLangOpts() const { return LangOpts; }
+  LangOptions &getLangOpts() { return LangOpts; }
   const TargetInfo &getTargetInfo() const { return *Target; }
   FileManager &getFileManager() const { return FileMgr; }
   SourceManager &getSourceManager() const { return SourceMgr; }
diff --git include/clang/Lex/PreprocessorOptions.h include/clang/Lex/PreprocessorOptions.h
index 963d95d..b939e40 100644
--- a/tools/clang/include/clang/Lex/PreprocessorOptions.h
+++ b/tools/clang/include/clang/Lex/PreprocessorOptions.h
@@ -58,6 +58,9 @@ public:
   /// The implicit PCH included at the start of the translation unit, or empty.
   std::string ImplicitPCHInclude;
 
+  /// The implicit PCH buffer included at the start of the translation unit, or empty.
+  llvm::MemoryBuffer *ImplicitPCHBuffer;
+
   /// \brief Headers that will be converted to chained PCHs in memory.
   std::vector<std::string> ChainedIncludes;
 
diff --git include/clang/Parse/Parser.h include/clang/Parse/Parser.h
index 8719555..88735e3 100644
--- a/tools/clang/include/clang/Parse/Parser.h
+++ b/tools/clang/include/clang/Parse/Parser.h
@@ -192,6 +192,73 @@ class Parser : public CodeCompletionHandler {
   /// The "depth" of the template parameters currently being parsed.
   unsigned TemplateParameterDepth;
 
+  class Function {
+    const DeclarationName myself;
+    std::vector<Function*>& FunctionCallGraph;
+    std::vector<Function*> calls;
+    bool called;
+
+    bool CheckForRecursion() {
+      if (called) {
+        called = false;
+        return false;
+      }
+
+      called = true;
+      std::vector<Function*>::iterator itr(calls.begin());
+      for (unsigned i=0; i<calls.size(); ++i, ++itr) {
+        Function* gFunction = *itr;
+        if (!gFunction->CheckForRecursion())
+        {
+          called = false;
+          return false;
+        }
+      }
+      called = false;
+
+      return true;
+    }
+
+  public:
+    Function(const DeclarationName myself, std::vector<Function*>& FunctionCallGraph)
+      : myself(myself), FunctionCallGraph(FunctionCallGraph), called(false) {}
+
+    bool AddCall(const DeclarationName call) {
+      std::vector<Function*>::iterator itr(FunctionCallGraph.begin());
+      for (unsigned i=0; i<FunctionCallGraph.size(); ++i, ++itr) {
+        Function* gFunction = *itr;
+        if (gFunction->myself == call) {
+          calls.push_back(gFunction);
+          return CheckForRecursion();
+        }
+      }
+
+      FunctionCallGraph.push_back(new Function(call, FunctionCallGraph));
+      calls.push_back(FunctionCallGraph.back());
+      return true;
+    }
+
+    bool IsMe(const DeclarationName call) {
+      return myself == call;
+    }
+  };
+
+  std::vector<Function*> FunctionCallGraph;
+  Function* currentFunction;
+
+  void AddToCallGraph(const DeclarationName call) {
+    std::vector<Function*>::iterator itr(FunctionCallGraph.begin());
+    for (unsigned i=0; i<FunctionCallGraph.size(); ++i, ++itr) {
+      Function* gFunction = *itr;
+      if (gFunction->IsMe(call)) {
+        return;
+      }
+    }
+
+    FunctionCallGraph.push_back(new Function(call, FunctionCallGraph));
+    currentFunction = FunctionCallGraph.back();
+  }
+
   /// \brief RAII class that manages the template parameter depth.
   class TemplateParameterDepthRAII {
     unsigned &Depth;
@@ -2178,8 +2245,19 @@ private:
   SourceLocation SkipExtendedMicrosoftTypeAttributes();
   void ParseMicrosoftInheritanceClassAttributes(ParsedAttributes &attrs);
   void ParseBorlandTypeAttributes(ParsedAttributes &attrs);
-  void ParseOpenCLAttributes(ParsedAttributes &attrs);
+  void ParseOpenCLKernelAttributes(ParsedAttributes &attrs);
   void ParseOpenCLQualifiers(ParsedAttributes &Attrs);
+  /// \brief Parses opencl_unroll_hint attribute if language is OpenCL v2.0
+  /// or higher.
+  /// \return false if error happens.
+  bool MaybeParseOpenCLUnrollHintAttribute(ParsedAttributes &Attrs) {
+    if (getLangOpts().OpenCL)
+      return ParseOpenCLUnrollHintAttribute(Attrs);
+    return true;
+  }
+  /// \brief Parses opencl_unroll_hint attribute.
+  /// \return false if error happens.
+  bool ParseOpenCLUnrollHintAttribute(ParsedAttributes &Attrs);
   void ParseNullabilityTypeSpecifiers(ParsedAttributes &attrs);
 
   VersionTuple ParseVersionTuple(SourceRange &Range);
diff --git include/clang/Sema/DeclSpec.h include/clang/Sema/DeclSpec.h
index 41d4900..5551734 100644
--- a/tools/clang/include/clang/Sema/DeclSpec.h
+++ b/tools/clang/include/clang/Sema/DeclSpec.h
@@ -303,6 +303,7 @@ public:
   static const TST TST_auto = clang::TST_auto;
   static const TST TST_unknown_anytype = clang::TST_unknown_anytype;
   static const TST TST_atomic = clang::TST_atomic;
+  static const TST TST_pipe = clang::TST_pipe;
   static const TST TST_error = clang::TST_error;
 
   // type-qualifiers
@@ -313,7 +314,8 @@ public:
     TQ_volatile    = 4,
     // This has no corresponding Qualifiers::TQ value, because it's not treated
     // as a qualifier in our type system.
-    TQ_atomic      = 8
+    TQ_atomic      = 8,
+    TQ_pipe        = 16
   };
 
   /// ParsedSpecifiers - Flags to query which specifiers were applied.  This is
@@ -343,7 +345,7 @@ private:
   unsigned TypeSpecOwned : 1;
 
   // type-qualifiers
-  unsigned TypeQualifiers : 4;  // Bitwise OR of TQ.
+  unsigned TypeQualifiers : 5;  // Bitwise OR of TQ.
 
   // function-specifier
   unsigned FS_inline_specified : 1;
@@ -385,7 +387,7 @@ private:
   /// TSTNameLoc provides source range info for tag types.
   SourceLocation TSTNameLoc;
   SourceRange TypeofParensRange;
-  SourceLocation TQ_constLoc, TQ_restrictLoc, TQ_volatileLoc, TQ_atomicLoc;
+  SourceLocation TQ_constLoc, TQ_restrictLoc, TQ_volatileLoc, TQ_atomicLoc, TQ_pipeLoc;
   SourceLocation FS_inlineLoc, FS_virtualLoc, FS_explicitLoc, FS_noreturnLoc;
   SourceLocation FS_forceinlineLoc;
   SourceLocation FriendLoc, ModulePrivateLoc, ConstexprLoc, ConceptLoc;
@@ -397,7 +399,7 @@ private:
 
   static bool isTypeRep(TST T) {
     return (T == TST_typename || T == TST_typeofType ||
-            T == TST_underlyingType || T == TST_atomic);
+            T == TST_underlyingType || T == TST_atomic || T == TST_pipe);
   }
   static bool isExprRep(TST T) {
     return (T == TST_typeofExpr || T == TST_decltype);
@@ -535,6 +537,7 @@ public:
   SourceLocation getRestrictSpecLoc() const { return TQ_restrictLoc; }
   SourceLocation getVolatileSpecLoc() const { return TQ_volatileLoc; }
   SourceLocation getAtomicSpecLoc() const { return TQ_atomicLoc; }
+  SourceLocation getPipeSpecLoc() const { return TQ_pipeLoc; }
 
   /// \brief Clear out all of the type qualifiers.
   void ClearTypeQualifiers() {
@@ -543,6 +546,7 @@ public:
     TQ_restrictLoc = SourceLocation();
     TQ_volatileLoc = SourceLocation();
     TQ_atomicLoc = SourceLocation();
+    TQ_pipeLoc = SourceLocation();
   }
 
   // function-specifier
@@ -1105,7 +1109,7 @@ struct DeclaratorChunk {
 
   struct PointerTypeInfo : TypeInfoCommon {
     /// The type qualifiers: const/volatile/restrict/atomic.
-    unsigned TypeQuals : 4;
+    unsigned TypeQuals : 5;
 
     /// The location of the const-qualifier, if any.
     unsigned ConstQualLoc;
@@ -1118,6 +1122,7 @@ struct DeclaratorChunk {
 
     /// The location of the _Atomic-qualifier, if any.
     unsigned AtomicQualLoc;
+    unsigned PipeQualLoc;
 
     void destroy() {
     }
@@ -1134,7 +1139,7 @@ struct DeclaratorChunk {
 
   struct ArrayTypeInfo : TypeInfoCommon {
     /// The type qualifiers for the array: const/volatile/restrict/_Atomic.
-    unsigned TypeQuals : 4;
+    unsigned TypeQuals : 5;
 
     /// True if this dimension included the 'static' keyword.
     bool hasStatic : 1;
@@ -1376,7 +1381,7 @@ struct DeclaratorChunk {
   struct BlockPointerTypeInfo : TypeInfoCommon {
     /// For now, sema will catch these as invalid.
     /// The type qualifiers: const/volatile/restrict/_Atomic.
-    unsigned TypeQuals : 4;
+    unsigned TypeQuals : 5;
 
     void destroy() {
     }
@@ -1384,7 +1389,7 @@ struct DeclaratorChunk {
 
   struct MemberPointerTypeInfo : TypeInfoCommon {
     /// The type qualifiers: const/volatile/restrict/_Atomic.
-    unsigned TypeQuals : 4;
+    unsigned TypeQuals : 5;
     // CXXScopeSpec has a constructor, so it can't be a direct member.
     // So we need some pointer-aligned storage and a bit of trickery.
     union {
diff --git include/clang/Sema/Overload.h include/clang/Sema/Overload.h
index 2007dcb..1615e1b 100644
--- a/tools/clang/include/clang/Sema/Overload.h
+++ b/tools/clang/include/clang/Sema/Overload.h
@@ -1,3 +1,4 @@
+
 //===--- Overload.h - C++ Overloading ---------------------------*- C++ -*-===//
 //
 //                     The LLVM Compiler Infrastructure
@@ -83,6 +84,7 @@ namespace clang {
     ICK_TransparentUnionConversion, ///< Transparent Union Conversions
     ICK_Writeback_Conversion,  ///< Objective-C ARC writeback conversion
     ICK_Zero_Event_Conversion, ///< Zero constant to event (OpenCL1.2 6.12.10)
+    ICK_Pipe_Void_PTR_Conversion, ///< Conversion from pipe(type) to pipe(void) *
     ICK_Num_Conversion_Kinds   ///< The number of conversion kinds
   };
 
diff --git include/clang/Sema/Sema.h include/clang/Sema/Sema.h
index 7204433..f0b9e2d 100644
--- a/tools/clang/include/clang/Sema/Sema.h
+++ b/tools/clang/include/clang/Sema/Sema.h
@@ -290,7 +290,7 @@ public:
   OpenCLOptions OpenCLFeatures;
   FPOptions FPFeatures;
 
-  const LangOptions &LangOpts;
+  LangOptions &LangOpts;
   Preprocessor &PP;
   ASTContext &Context;
   ASTConsumer &Consumer;
@@ -1249,6 +1249,7 @@ public:
                                  SourceLocation Loc, DeclarationName Entity);
   QualType BuildParenType(QualType T);
   QualType BuildAtomicType(QualType T, SourceLocation Loc);
+  QualType BuildPipeType(QualType T, SourceLocation Loc);
 
   TypeSourceInfo *GetTypeForDeclarator(Declarator &D, Scope *S);
   TypeSourceInfo *GetTypeForDeclaratorCast(Declarator &D, QualType FromTy);
@@ -1606,7 +1607,8 @@ public:
                             SourceLocation ConstQualLoc = SourceLocation(),
                             SourceLocation VolatileQualLoc = SourceLocation(),
                             SourceLocation RestrictQualLoc = SourceLocation(),
-                            SourceLocation AtomicQualLoc = SourceLocation());
+                            SourceLocation AtomicQualLoc = SourceLocation(),
+                            SourceLocation PipeQualLoc = SourceLocation());
 
   static bool adjustContextForLocalExternDecl(DeclContext *&DC);
   void DiagnoseFunctionSpecifiers(const DeclSpec &DS);
diff --git include/clang/Serialization/ASTBitCodes.h include/clang/Serialization/ASTBitCodes.h
index 4b66207..2c9f25f 100644
--- a/tools/clang/include/clang/Serialization/ASTBitCodes.h
+++ b/tools/clang/include/clang/Serialization/ASTBitCodes.h
@@ -769,15 +769,35 @@ namespace clang {
       /// \brief OpenCL 1d image buffer type.
       PREDEF_TYPE_IMAGE1D_BUFF_ID = 40,
       /// \brief OpenCL 2d image type.
-      PREDEF_TYPE_IMAGE2D_ID    = 41,
+      PREDEF_TYPE_IMAGE2D_ID     = 41,
       /// \brief OpenCL 2d image array type.
       PREDEF_TYPE_IMAGE2D_ARR_ID = 42,
+      /// \brief OpenCL 2d image depth type.
+      PREDEF_TYPE_IMAGE2D_DEP_ID = 43,
+      /// \brief OpenCL 2d image array depth type.
+      PREDEF_TYPE_IMAGE2D_ARR_DEP_ID = 44,
+      /// \brief OpenCL 2d image MSAA type.
+      PREDEF_TYPE_IMAGE2D_MSAA_ID = 45,
+      /// \brief OpenCL 2d image array MSAA type.
+      PREDEF_TYPE_IMAGE2D_ARR_MSAA_ID = 46,
+      /// \brief OpenCL 2d image MSAA depth type.
+      PREDEF_TYPE_IMAGE2D_MSAA_DEP_ID = 47,
+      /// \brief OpenCL 2d image array MSAA depth type.
+      PREDEF_TYPE_IMAGE2D_ARR_MSAA_DEPTH_ID = 48,
       /// \brief OpenCL 3d image type.
-      PREDEF_TYPE_IMAGE3D_ID    = 43,
+      PREDEF_TYPE_IMAGE3D_ID    = 49,
       /// \brief OpenCL event type.
-      PREDEF_TYPE_EVENT_ID      = 44,
+      PREDEF_TYPE_EVENT_ID      = 50,
+      /// \brief OpenCL clk event type.
+      PREDEF_TYPE_CLK_EVENT_ID  = 51,
       /// \brief OpenCL sampler type.
-      PREDEF_TYPE_SAMPLER_ID    = 45
+      PREDEF_TYPE_SAMPLER_ID    = 52,
+      /// \brief OpenCL queue type.
+      PREDEF_TYPE_QUEUE_ID      = 53,
+      /// \brief OpenCL ndrange type.
+      PREDEF_TYPE_NDRANGE_ID    = 54,
+      /// \brief OpenCL reserve_id type.
+      PREDEF_TYPE_RESERVE_ID_ID = 55
     };
 
     /// \brief The number of predefined type IDs that are reserved for
@@ -875,7 +895,8 @@ namespace clang {
       /// \brief A DecayedType record.
       TYPE_DECAYED               = 41,
       /// \brief An AdjustedType record.
-      TYPE_ADJUSTED              = 42
+      TYPE_ADJUSTED              = 42,
+      TYPE_PIPE                  = 43
     };
 
     /// \brief The type IDs for special types constructed by semantic
diff --git lib/AST/ASTContext.cpp lib/AST/ASTContext.cpp
index fb96301..f28d197 100644
--- a/tools/clang/lib/AST/ASTContext.cpp
+++ b/tools/clang/lib/AST/ASTContext.cpp
@@ -701,6 +701,7 @@ static const LangAS::Map *getAddressSpaceMap(const TargetInfo &T,
       2, // opencl_local
       3, // opencl_constant
       4, // opencl_generic
+      0, // opencl_private
       5, // cuda_device
       6, // cuda_constant
       7  // cuda_shared
@@ -1059,10 +1060,20 @@ void ASTContext::InitBuiltinTypes(const TargetInfo &Target) {
     InitBuiltinType(OCLImage1dBufferTy, BuiltinType::OCLImage1dBuffer);
     InitBuiltinType(OCLImage2dTy, BuiltinType::OCLImage2d);
     InitBuiltinType(OCLImage2dArrayTy, BuiltinType::OCLImage2dArray);
+    InitBuiltinType(OCLImage2dDepthTy, BuiltinType::OCLImage2dDepth);
+    InitBuiltinType(OCLImage2dArrayDepthTy, BuiltinType::OCLImage2dArrayDepth);
+    InitBuiltinType(OCLImage2dMSAATy, BuiltinType::OCLImage2dMSAA);
+    InitBuiltinType(OCLImage2dArrayMSAATy, BuiltinType::OCLImage2dArrayMSAA);
+    InitBuiltinType(OCLImage2dMSAADepthTy, BuiltinType::OCLImage2dMSAADepth);
+    InitBuiltinType(OCLImage2dArrayMSAADepthTy, BuiltinType::OCLImage2dArrayMSAADepth);
     InitBuiltinType(OCLImage3dTy, BuiltinType::OCLImage3d);
 
     InitBuiltinType(OCLSamplerTy, BuiltinType::OCLSampler);
     InitBuiltinType(OCLEventTy, BuiltinType::OCLEvent);
+    InitBuiltinType(OCLClkEventTy, BuiltinType::OCLClkEvent);
+    InitBuiltinType(OCLQueueTy, BuiltinType::OCLQueue);
+    InitBuiltinType(OCLNDRangeTy, BuiltinType::OCLNDRange);
+    InitBuiltinType(OCLReserveIDTy, BuiltinType::OCLReserveID);
   }
   
   // Builtin type for __objc_yes and __objc_no
@@ -1629,11 +1640,21 @@ TypeInfo ASTContext::getTypeInfoImpl(const Type *T) const {
       Align = Target->getIntAlign();
       break;
     case BuiltinType::OCLEvent:
+    case BuiltinType::OCLClkEvent:
+    case BuiltinType::OCLQueue:
+    case BuiltinType::OCLNDRange:
+    case BuiltinType::OCLReserveID:
     case BuiltinType::OCLImage1d:
     case BuiltinType::OCLImage1dArray:
     case BuiltinType::OCLImage1dBuffer:
     case BuiltinType::OCLImage2d:
     case BuiltinType::OCLImage2dArray:
+    case BuiltinType::OCLImage2dDepth:
+    case BuiltinType::OCLImage2dArrayDepth:
+    case BuiltinType::OCLImage2dMSAA:
+    case BuiltinType::OCLImage2dArrayMSAA:
+    case BuiltinType::OCLImage2dMSAADepth:
+    case BuiltinType::OCLImage2dArrayMSAADepth:
     case BuiltinType::OCLImage3d:
       // Currently these types are pointers to opaque types.
       Width = Target->getPointerWidth(0);
@@ -1778,6 +1799,14 @@ TypeInfo ASTContext::getTypeInfoImpl(const Type *T) const {
       // Set the alignment equal to the size.
       Align = static_cast<unsigned>(Width);
     }
+    break;
+  }
+  case Type::Pipe: {
+    // Start with the base type information.
+    TypeInfo Info = getTypeInfo(cast<PipeType>(T)->getValueType());
+    Width = Info.Width;
+    Align = Info.Align;
+    break;
   }
 
   }
@@ -2627,6 +2656,12 @@ QualType ASTContext::getVariableArrayDecayedType(QualType type) const {
     break;
   }
 
+  case Type::Pipe: {
+    const PipeType *at = cast<PipeType>(ty);
+    result = getPipeType(getVariableArrayDecayedType(at->getValueType()));
+    break;
+  }
+
   case Type::ConstantArray: {
     const ConstantArrayType *cat = cast<ConstantArrayType>(ty);
     result = getConstantArrayType(
@@ -3970,6 +4005,34 @@ QualType ASTContext::getAtomicType(QualType T) const {
   return QualType(New, 0);
 }
 
+/// getPipeType - Return the uniqued reference to the pipe type for
+/// the given value type.
+QualType ASTContext::getPipeType(QualType T) const {
+  // Unique pointers, to guarantee there is only one pointer of a particular
+  // structure.
+  llvm::FoldingSetNodeID ID;
+  PipeType::Profile(ID, T);
+
+  void *InsertPos = nullptr;
+  if (PipeType *AT = PipeTypes.FindNodeOrInsertPos(ID, InsertPos))
+    return QualType(AT, 0);
+
+  // If the pipe value type isn't canonical, this won't be a canonical type
+  // either, so fill in the canonical type field.
+  QualType Canonical;
+  if (!T.isCanonical()) {
+    Canonical = getPipeType(getCanonicalType(T));
+
+    // Get the new insert position for the node we care about.
+    PipeType *NewIP = PipeTypes.FindNodeOrInsertPos(ID, InsertPos);
+    assert(!NewIP && "Shouldn't be in the map!"); (void)NewIP;
+  }
+  PipeType *New = new (*this, TypeAlignment) PipeType(T, Canonical);
+  Types.push_back(New);
+  PipeTypes.InsertNode(New, InsertPos);
+  return QualType(New, 0);
+}
+
 /// getAutoDeductType - Get type pattern for deducing against 'auto'.
 QualType ASTContext::getAutoDeductType() const {
   if (AutoDeductTy.isNull())
@@ -5364,8 +5427,18 @@ static char getObjCEncodingForPrimitiveKind(const ASTContext *C,
     case BuiltinType::OCLImage1dBuffer:
     case BuiltinType::OCLImage2d:
     case BuiltinType::OCLImage2dArray:
+    case BuiltinType::OCLImage2dDepth:
+    case BuiltinType::OCLImage2dArrayDepth:
+    case BuiltinType::OCLImage2dMSAA:
+    case BuiltinType::OCLImage2dArrayMSAA:
+    case BuiltinType::OCLImage2dMSAADepth:
+    case BuiltinType::OCLImage2dArrayMSAADepth:
     case BuiltinType::OCLImage3d:
     case BuiltinType::OCLEvent:
+    case BuiltinType::OCLClkEvent:
+    case BuiltinType::OCLQueue:
+    case BuiltinType::OCLNDRange:
+    case BuiltinType::OCLReserveID:
     case BuiltinType::OCLSampler:
     case BuiltinType::Dependent:
 #define BUILTIN_TYPE(KIND, ID)
@@ -5452,7 +5525,8 @@ void ASTContext::getObjCEncodingForTypeImpl(QualType T, std::string& S,
     getObjCEncodingForTypeImpl(CT->getElementType(), S, false, false, nullptr);
     return;
   }
-
+  case Type::Pipe:
+    llvm_unreachable("No support for pipes in ObjC");
   case Type::Atomic: {
     const AtomicType *AT = T->castAs<AtomicType>();
     S += 'A';
@@ -7621,6 +7695,24 @@ QualType ASTContext::mergeTypes(QualType LHS, QualType RHS,
       return RHS;
     return getAtomicType(ResultType);
   }
+  case Type::Pipe:
+  {
+    // Merge two pointer types, while trying to preserve typedef info
+    QualType LHSValue = LHS->getAs<PipeType>()->getValueType();
+    QualType RHSValue = RHS->getAs<PipeType>()->getValueType();
+    if (Unqualified) {
+      LHSValue = LHSValue.getUnqualifiedType();
+      RHSValue = RHSValue.getUnqualifiedType();
+    }
+    QualType ResultType = mergeTypes(LHSValue, RHSValue, false, 
+                                     Unqualified);
+    if (ResultType.isNull()) return QualType();
+    if (getCanonicalType(LHSValue) == getCanonicalType(ResultType))
+      return LHS;
+    if (getCanonicalType(RHSValue) == getCanonicalType(ResultType))
+      return RHS;
+    return getPipeType(ResultType);
+  }
   case Type::ConstantArray:
   {
     const ConstantArrayType* LCAT = getAsConstantArrayType(LHS);
diff --git lib/AST/ASTDumper.cpp lib/AST/ASTDumper.cpp
index c95922b..bbefd20 100644
--- a/tools/clang/lib/AST/ASTDumper.cpp
+++ b/tools/clang/lib/AST/ASTDumper.cpp
@@ -401,6 +401,9 @@ namespace  {
     void VisitAtomicType(const AtomicType *T) {
       dumpTypeAsChild(T->getValueType());
     }
+    void VisitPipeType(const PipeType *T) {
+      dumpTypeAsChild(T->getValueType());
+    }
     void VisitAdjustedType(const AdjustedType *T) {
       dumpTypeAsChild(T->getOriginalType());
     }
diff --git lib/AST/ASTImporter.cpp lib/AST/ASTImporter.cpp
index 35c0f69..80acb85 100644
--- a/tools/clang/lib/AST/ASTImporter.cpp
+++ b/tools/clang/lib/AST/ASTImporter.cpp
@@ -877,6 +877,13 @@ static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,
       return false;
     break;
   }
+  case Type::Pipe: {
+    if (!IsStructurallyEquivalent(Context,
+                                  cast<PipeType>(T1)->getValueType(),
+                                  cast<PipeType>(T2)->getValueType()))
+      return false;
+    break;
+  }
 
   } // end switch
 
diff --git lib/AST/ItaniumMangle.cpp lib/AST/ItaniumMangle.cpp
index dac803e..c816b5f 100644
--- a/tools/clang/lib/AST/ItaniumMangle.cpp
+++ b/tools/clang/lib/AST/ItaniumMangle.cpp
@@ -1510,6 +1510,7 @@ bool CXXNameMangler::mangleUnresolvedTypeOrSimpleId(QualType Ty,
   case Type::ObjCInterface:
   case Type::ObjCObjectPointer:
   case Type::Atomic:
+  case Type::Pipe:
     llvm_unreachable("type is illegal as a nested name specifier");
 
   case Type::SubstTemplateTypeParmPack:
@@ -1793,6 +1794,8 @@ void CXXNameMangler::mangleQualifiers(Qualifiers Quals) {
       case LangAS::opencl_global:   ASString = "CLglobal";   break;
       case LangAS::opencl_local:    ASString = "CLlocal";    break;
       case LangAS::opencl_constant: ASString = "CLconstant"; break;
+      case LangAS::opencl_generic:  ASString = "CLgeneric";  break;
+      case LangAS::opencl_private:  ASString = "CLprivate";  break;
       //  <CUDA-addrspace> ::= "CU" [ "device" | "constant" | "shared" ]
       case LangAS::cuda_device:     ASString = "CUdevice";   break;
       case LangAS::cuda_constant:   ASString = "CUconstant"; break;
@@ -2031,9 +2034,19 @@ void CXXNameMangler::mangleType(const BuiltinType *T) {
   case BuiltinType::OCLImage1dBuffer: Out << "17ocl_image1dbuffer"; break;
   case BuiltinType::OCLImage2d: Out << "11ocl_image2d"; break;
   case BuiltinType::OCLImage2dArray: Out << "16ocl_image2darray"; break;
+  case BuiltinType::OCLImage2dDepth: Out << "16ocl_image2ddepth"; break;
+  case BuiltinType::OCLImage2dArrayDepth: Out << "21ocl_image2darraydepth"; break;
+  case BuiltinType::OCLImage2dMSAA: Out << "15ocl_image2dmsaa"; break;
+  case BuiltinType::OCLImage2dArrayMSAA: Out << "20ocl_image2darraymsaa"; break;
+  case BuiltinType::OCLImage2dMSAADepth: Out << "20ocl_image2dmsaadepth"; break;
+  case BuiltinType::OCLImage2dArrayMSAADepth: Out << "35ocl_image2darraymsaadepth"; break;
   case BuiltinType::OCLImage3d: Out << "11ocl_image3d"; break;
   case BuiltinType::OCLSampler: Out << "11ocl_sampler"; break;
   case BuiltinType::OCLEvent: Out << "9ocl_event"; break;
+  case BuiltinType::OCLClkEvent: Out << "12ocl_clkevent"; break;
+  case BuiltinType::OCLQueue: Out << "9ocl_queue"; break;
+  case BuiltinType::OCLNDRange: Out << "11ocl_ndrange"; break;
+  case BuiltinType::OCLReserveID: Out << "13ocl_reserveid"; break;
   }
 }
 
@@ -2556,6 +2569,13 @@ void CXXNameMangler::mangleType(const AtomicType *T) {
   mangleType(T->getValueType());
 }
 
+void CXXNameMangler::mangleType(const PipeType *T) {
+  // <type> ::= U <source-name> <type>  # vendor extended type qualifier
+  // (Until there's a standardized mangling...)
+  Out << "U4pipe";
+  mangleType(T->getValueType());
+}
+
 void CXXNameMangler::mangleIntegerLiteral(QualType T,
                                           const llvm::APSInt &Value) {
   //  <expr-primary> ::= L <type> <value number> E # integer literal
diff --git lib/AST/MicrosoftMangle.cpp lib/AST/MicrosoftMangle.cpp
index 48a8fa5..44d1bb9 100644
--- a/tools/clang/lib/AST/MicrosoftMangle.cpp
+++ b/tools/clang/lib/AST/MicrosoftMangle.cpp
@@ -1586,9 +1586,19 @@ void MicrosoftCXXNameMangler::mangleType(const BuiltinType *T, Qualifiers,
   case BuiltinType::OCLImage1dBuffer: Out << "PAUocl_image1dbuffer@@"; break;
   case BuiltinType::OCLImage2d: Out << "PAUocl_image2d@@"; break;
   case BuiltinType::OCLImage2dArray: Out << "PAUocl_image2darray@@"; break;
+  case BuiltinType::OCLImage2dDepth: Out << "PAUocl_image2ddepth@@"; break;
+  case BuiltinType::OCLImage2dArrayDepth: Out << "PAUocl_image2darraydepth@@"; break;
+  case BuiltinType::OCLImage2dMSAA: Out << "PAUocl_image2dmsaa@@"; break;
+  case BuiltinType::OCLImage2dArrayMSAA: Out << "PAUocl_image2darraymsaa@@"; break;
+  case BuiltinType::OCLImage2dMSAADepth: Out << "PAUocl_image2dmsaadepth@@"; break;
+  case BuiltinType::OCLImage2dArrayMSAADepth: Out << "PAUocl_image2darraymsaadepth@@"; break;
   case BuiltinType::OCLImage3d: Out << "PAUocl_image3d@@"; break;
   case BuiltinType::OCLSampler: Out << "PAUocl_sampler@@"; break;
   case BuiltinType::OCLEvent: Out << "PAUocl_event@@"; break;
+  case BuiltinType::OCLClkEvent: Out << "PAUocl_clkevent@@"; break;
+  case BuiltinType::OCLQueue: Out << "PAUocl_queue@@"; break;
+  case BuiltinType::OCLNDRange: Out << "PAUocl_ndrange@@"; break;
+  case BuiltinType::OCLReserveID: Out << "PAUocl_reserveid@@"; break;
 
   case BuiltinType::NullPtr: Out << "$$T"; break;
 
@@ -2216,6 +2226,15 @@ void MicrosoftCXXNameMangler::mangleType(const AtomicType *T, Qualifiers,
     << Range;
 }
 
+void MicrosoftCXXNameMangler::mangleType(const PipeType *T, Qualifiers,
+                                         SourceRange Range) {
+  DiagnosticsEngine &Diags = Context.getDiags();
+  unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,
+    "cannot mangle this pipe type yet");
+  Diags.Report(Range.getBegin(), DiagID)
+    << Range;
+}
+
 void MicrosoftMangleContextImpl::mangleCXXName(const NamedDecl *D,
                                                raw_ostream &Out) {
   assert((isa<FunctionDecl>(D) || isa<VarDecl>(D)) &&
diff --git lib/AST/NSAPI.cpp lib/AST/NSAPI.cpp
index c9264d5..a43d5f7 100644
--- a/tools/clang/lib/AST/NSAPI.cpp
+++ b/tools/clang/lib/AST/NSAPI.cpp
@@ -450,9 +450,19 @@ NSAPI::getNSNumberFactoryMethodKind(QualType T) const {
   case BuiltinType::OCLImage1dBuffer:
   case BuiltinType::OCLImage2d:
   case BuiltinType::OCLImage2dArray:
+  case BuiltinType::OCLImage2dDepth:
+  case BuiltinType::OCLImage2dArrayDepth:
+  case BuiltinType::OCLImage2dMSAA:
+  case BuiltinType::OCLImage2dArrayMSAA:
+  case BuiltinType::OCLImage2dMSAADepth:
+  case BuiltinType::OCLImage2dArrayMSAADepth:
   case BuiltinType::OCLImage3d:
   case BuiltinType::OCLSampler:
   case BuiltinType::OCLEvent:
+  case BuiltinType::OCLClkEvent:
+  case BuiltinType::OCLQueue:
+  case BuiltinType::OCLNDRange:
+  case BuiltinType::OCLReserveID:
   case BuiltinType::BoundMember:
   case BuiltinType::Dependent:
   case BuiltinType::Overload:
diff --git lib/AST/Type.cpp lib/AST/Type.cpp
index cee5fee..3dc6b88 100644
--- a/tools/clang/lib/AST/Type.cpp
+++ b/tools/clang/lib/AST/Type.cpp
@@ -2165,6 +2165,9 @@ bool Type::isLiteralType(const ASTContext &Ctx) const {
   if (const AtomicType *AT = BaseTy->getAs<AtomicType>())
     return AT->getValueType()->isLiteralType(Ctx);
 
+  if (const PipeType *AT = BaseTy->getAs<PipeType>())
+    return AT->getValueType()->isLiteralType(Ctx);
+
   // If this type hasn't been deduced yet, then conservatively assume that
   // it'll work out to be a literal type.
   if (isa<AutoType>(BaseTy->getCanonicalTypeInternal()))
@@ -2513,9 +2516,19 @@ StringRef BuiltinType::getName(const PrintingPolicy &Policy) const {
   case OCLImage1dBuffer:  return "image1d_buffer_t";
   case OCLImage2d:        return "image2d_t";
   case OCLImage2dArray:   return "image2d_array_t";
+  case OCLImage2dDepth:   return "image2d_depth_t";
+  case OCLImage2dArrayDepth: return "image2d_array_depth_t";
+  case OCLImage2dMSAA:    return "image2d_msaa_t";
+  case OCLImage2dArrayMSAA: return "image2d_array_msaa_t";
+  case OCLImage2dMSAADepth: return "image2d_msaa_depth_t";
+  case OCLImage2dArrayMSAADepth: return "image2d_array_msaa_depth_t";
   case OCLImage3d:        return "image3d_t";
   case OCLSampler:        return "sampler_t";
   case OCLEvent:          return "event_t";
+  case OCLClkEvent:       return "clk_event_t";
+  case OCLQueue:          return "queue_t";
+  case OCLNDRange:        return "event_t";
+  case OCLReserveID:      return "reserve_id_t";
   }
   
   llvm_unreachable("Invalid builtin type.");
@@ -3215,6 +3228,8 @@ static CachedProperties computeCachedProperties(const Type *T) {
     return Cache::get(cast<ObjCObjectPointerType>(T)->getPointeeType());
   case Type::Atomic:
     return Cache::get(cast<AtomicType>(T)->getValueType());
+  case Type::Pipe:
+    return Cache::get(cast<PipeType>(T)->getValueType());
   }
 
   llvm_unreachable("unhandled type class");
@@ -3297,6 +3312,8 @@ static LinkageInfo computeLinkageInfo(const Type *T) {
     return computeLinkageInfo(cast<ObjCObjectPointerType>(T)->getPointeeType());
   case Type::Atomic:
     return computeLinkageInfo(cast<AtomicType>(T)->getValueType());
+  case Type::Pipe:
+    return computeLinkageInfo(cast<PipeType>(T)->getValueType());
   }
 
   llvm_unreachable("unhandled type class");
@@ -3444,6 +3461,7 @@ bool Type::canHaveNullability() const {
   case Type::ObjCObject:
   case Type::ObjCInterface:
   case Type::Atomic:
+  case Type::Pipe:
     return false;
   }
   llvm_unreachable("bad type kind!");
diff --git lib/AST/TypeLoc.cpp lib/AST/TypeLoc.cpp
index 85bda6a..380b6cd 100644
--- a/tools/clang/lib/AST/TypeLoc.cpp
+++ b/tools/clang/lib/AST/TypeLoc.cpp
@@ -338,9 +338,19 @@ TypeSpecifierType BuiltinTypeLoc::getWrittenTypeSpec() const {
   case BuiltinType::OCLImage1dBuffer:
   case BuiltinType::OCLImage2d:
   case BuiltinType::OCLImage2dArray:
+  case BuiltinType::OCLImage2dDepth:
+  case BuiltinType::OCLImage2dArrayDepth:
+  case BuiltinType::OCLImage2dMSAA:
+  case BuiltinType::OCLImage2dArrayMSAA:
+  case BuiltinType::OCLImage2dMSAADepth:
+  case BuiltinType::OCLImage2dArrayMSAADepth:
   case BuiltinType::OCLImage3d:
   case BuiltinType::OCLSampler:
   case BuiltinType::OCLEvent:
+  case BuiltinType::OCLClkEvent:
+  case BuiltinType::OCLQueue:
+  case BuiltinType::OCLNDRange:
+  case BuiltinType::OCLReserveID:
   case BuiltinType::BuiltinFn:
     return TST_unspecified;
   }
diff --git lib/AST/TypePrinter.cpp lib/AST/TypePrinter.cpp
index 0bb50c6..d51714b 100644
--- a/tools/clang/lib/AST/TypePrinter.cpp
+++ b/tools/clang/lib/AST/TypePrinter.cpp
@@ -193,6 +193,7 @@ bool TypePrinter::canPrefixQualifiers(const Type *T,
     case Type::ObjCObject:
     case Type::ObjCInterface:
     case Type::Atomic:
+    case Type::Pipe:
       CanPrefixQualifiers = true;
       break;
       
@@ -855,6 +856,16 @@ void TypePrinter::printAtomicBefore(const AtomicType *T, raw_ostream &OS) {
 }
 void TypePrinter::printAtomicAfter(const AtomicType *T, raw_ostream &OS) { }
 
+void TypePrinter::printPipeBefore(const PipeType *T, raw_ostream &OS) {
+  IncludeStrongLifetimeRAII Strong(Policy);
+
+  OS << "pipe(";
+  print(T->getValueType(), OS, StringRef());
+  OS << ')';
+  spaceBeforePlaceHolder(OS);
+}
+void TypePrinter::printPipeAfter(const PipeType *T, raw_ostream &OS) { }
+
 /// Appends the given scope to the end of a string.
 void TypePrinter::AppendScope(DeclContext *DC, raw_ostream &OS) {
   if (DC->isTranslationUnit()) return;
@@ -1530,6 +1541,9 @@ void Qualifiers::print(raw_ostream &OS, const PrintingPolicy& Policy,
       OS << ' ';
     addSpace = true;
     switch (addrspace) {
+      case LangAS::opencl_private:
+        OS << "__private";
+        break;
       case LangAS::opencl_global:
         OS << "__global";
         break;
diff --git lib/ASTMatchers/Dynamic/Registry.cpp lib/ASTMatchers/Dynamic/Registry.cpp
index 72713dd..bbb91fd 100644
--- a/tools/clang/lib/ASTMatchers/Dynamic/Registry.cpp
+++ b/tools/clang/lib/ASTMatchers/Dynamic/Registry.cpp
@@ -104,6 +104,7 @@ RegistryMaps::RegistryMaps() {
   REGISTER_MATCHER(asmStmt);
   REGISTER_MATCHER(asString);
   REGISTER_MATCHER(atomicType);
+  REGISTER_MATCHER(pipeType);
   REGISTER_MATCHER(autoType);
   REGISTER_MATCHER(binaryOperator);
   REGISTER_MATCHER(bindTemporaryExpr);
diff --git lib/Basic/FileManager.cpp lib/Basic/FileManager.cpp
index d492744..e0595a6 100644
--- a/tools/clang/lib/Basic/FileManager.cpp
+++ b/tools/clang/lib/Basic/FileManager.cpp
@@ -346,8 +346,7 @@ FileManager::getVirtualFile(StringRef Filename, off_t Size,
   // cache.
   const DirectoryEntry *DirInfo = getDirectoryFromFile(*this, Filename,
                                                        /*CacheFailure=*/true);
-  assert(DirInfo &&
-         "The directory of a virtual file should already be in the cache.");
+  if (DirInfo == 0) return nullptr;
 
   // Check to see if the file exists. If so, drop the virtual file
   FileData Data;
diff --git lib/Basic/SourceManager.cpp lib/Basic/SourceManager.cpp
index c0b0453..7858b02 100644
--- a/tools/clang/lib/Basic/SourceManager.cpp
+++ b/tools/clang/lib/Basic/SourceManager.cpp
@@ -685,6 +685,11 @@ StringRef SourceManager::getBufferData(FileID FID, bool *Invalid) const {
     return "<<<<<INVALID SOURCE LOCATION>>>>>";
   }
 
+  if (SLoc.getFile().getContentCache() == 0) {
+    *Invalid = true;
+    return "(Unknown source location)";
+  }
+
   llvm::MemoryBuffer *Buf = SLoc.getFile().getContentCache()->getBuffer(
       Diag, *this, SourceLocation(), &MyInvalid);
   if (Invalid)
@@ -1294,7 +1299,9 @@ unsigned SourceManager::getLineNumber(FileID FID, unsigned FilePos,
     
     Content = const_cast<ContentCache*>(Entry.getFile().getContentCache());
   }
-  
+
+  if (Content == 0) return 0;
+
   // If this is the first use of line information for this buffer, compute the
   /// SourceLineCache for it on demand.
   if (!Content->SourceLineCache) {
@@ -1453,6 +1460,8 @@ PresumedLoc SourceManager::getPresumedLoc(SourceLocation Loc,
   const SrcMgr::FileInfo &FI = Entry.getFile();
   const SrcMgr::ContentCache *C = FI.getContentCache();
 
+  if (C == nullptr) return PresumedLoc();
+
   // To get the source name, first consult the FileEntry (if one exists)
   // before the MemBuffer as this will avoid unnecessarily paging in the
   // MemBuffer.
diff --git lib/Basic/TargetInfo.cpp lib/Basic/TargetInfo.cpp
index dbd2f9a..c4e9651 100644
--- a/tools/clang/lib/Basic/TargetInfo.cpp
+++ b/tools/clang/lib/Basic/TargetInfo.cpp
@@ -297,7 +297,7 @@ void TargetInfo::adjust(const LangOptions &Opts) {
     LongDoubleWidth = LongDoubleAlign = 128;
 
     assert(PointerWidth == 32 || PointerWidth == 64);
-    bool Is32BitArch = PointerWidth == 32;
+    bool Is32BitArch = getPointerWidthV(1) == 32;
     SizeType = Is32BitArch ? UnsignedInt : UnsignedLong;
     PtrDiffType = Is32BitArch ? SignedInt : SignedLong;
     IntPtrType = Is32BitArch ? SignedInt : SignedLong;
diff --git lib/Basic/Targets.cpp lib/Basic/Targets.cpp
index e4db004..658bd5c 100644
--- a/tools/clang/lib/Basic/Targets.cpp
+++ b/tools/clang/lib/Basic/Targets.cpp
@@ -1565,6 +1565,7 @@ public:
     4,    // opencl_constant
     // FIXME: generic has to be added to the target
     0,    // opencl_generic
+    0,    // opencl_private
     1,    // cuda_device
     4,    // cuda_constant
     3,    // cuda_shared
@@ -1722,6 +1723,7 @@ static const unsigned AMDGPUAddrSpaceMap[] = {
   3,    // opencl_local
   2,    // opencl_constant
   4,    // opencl_generic
+  0,    // opencl_private
   1,    // cuda_device
   2,    // cuda_constant
   3     // cuda_shared
@@ -4202,6 +4204,7 @@ public:
       : TargetInfo(Triple), CPU("arm1136j-s"), FPMath(FP_Default),
         IsAAPCS(true), HW_FP(0) {
     BigEndian = IsBigEndian;
+    IntMaxType = SignedLong;
 
     switch (getTriple().getOS()) {
     case llvm::Triple::NetBSD:
@@ -4365,6 +4368,8 @@ public:
       } else if (Feature == "+neon") {
         FPU |= NeonFPU;
         HW_FP |= HW_FP_SP | HW_FP_DP;
+     } else if (Feature == "+long64") {
+        LongWidth = LongAlign = 64;  // RS uses a 64-bit long type
       } else if (Feature == "+hwdiv") {
         HWDiv |= HWDivThumb;
       } else if (Feature == "+hwdiv-arm") {
@@ -5856,6 +5861,228 @@ validateAsmConstraint(const char *&Name,
   }
 }
 
+namespace {
+const unsigned USCOpenCLAddrSpaceMap[] = {
+  1, // opencl_global
+  3, // opencl_local
+  2, // opencl_constant
+  4, // opencl_generic
+  0, // opencl_private
+  1, // cuda_device
+  2, // cuda_constant
+  3  // cuda_shared
+};
+
+  class USCTargetInfo : public TargetInfo {
+  public:
+    USCTargetInfo(const llvm::Triple &Triple) : TargetInfo(Triple) {
+      if (Triple.getArch() == llvm::Triple::usc) {
+        PointerWidth = 32;
+        PointerAlign = 32;
+        SizeType = UnsignedInt;
+        IntPtrType = SignedInt;
+        PtrDiffType = SignedInt;
+        DescriptionString = "e-p:32:32:32-a:0:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f16:16:16-f32:32:32-f64:32:64-n8:16:32";
+      } else {
+        PointerWidth = 64;
+        PointerAlign = 64;
+        SizeType = UnsignedLong;
+        IntPtrType = SignedLong;
+        PtrDiffType = SignedLong;
+        DescriptionString = "e-p:64:64:64-a:0:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f16:16:16-f32:32:32-f64:32:64-n8:16:32:64";
+      }
+
+      TLSSupported = false;
+      IntWidth = 32;
+      IntAlign = 32;
+      LongWidth = LongLongWidth = 64;
+      LongAlign = LongLongAlign = 64;
+      IntMaxType = SignedLong;
+
+      HalfWidth = 16;
+      HalfAlign = 16;
+      HalfFormat = &llvm::APFloat::IEEEhalf;
+
+      FloatWidth = 32;
+      FloatAlign = 32;
+      FloatFormat = &llvm::APFloat::IEEEsingle;
+
+      // Make double the same as float since we don't support it
+      DoubleAlign = 32;
+      DoubleWidth = 32;
+      DoubleFormat = &llvm::APFloat::IEEEsingle;
+
+      this->AddrSpaceMap = &USCOpenCLAddrSpaceMap;
+    }
+
+    // The USC target correctly returns the bitwidth of
+    // the integer when doing a CLZ(0).
+    bool isCLZForZeroUndef() const override { return false; }
+
+    void getTargetDefines(const LangOptions& Opts, MacroBuilder& Builder) const {
+      bool CL2 = false;
+      // Insert OpenCL definitions here as they are specific to the USC target
+      Builder.defineMacro("__IMAGE_SUPPORT__", "1");
+      Builder.defineMacro("__EMBEDDED_PROFILE__");
+      Builder.defineMacro("__ENDIAN_LITTLE__","1");
+      Builder.defineMacro("__kernel_exec(X, typen)",
+                          "__kernel __attribute__((work_group_size_hint(X, 1, 1)))"
+                          "__attribute__((vec_type_hint(typen)))");
+      Builder.defineMacro("kernel_exec(X, typen)", "__kernel_exec(X, typen)");
+      Builder.defineMacro("CL_VERSION_1_0", "100");
+      Builder.defineMacro("CL_VERSION_1_1", "110");
+      Builder.defineMacro("CL_VERSION_1_2", "120");
+      Builder.defineMacro("CL_VERSION_2_0", "200");
+      if (Opts.OpenCLVersion == 100)
+        Builder.defineMacro("__OPENCL_VERSION__", "100");
+      else if (Opts.OpenCLVersion == 110)
+        Builder.defineMacro("__OPENCL_VERSION__", "110");
+      else if (Opts.OpenCLVersion == 120)
+        Builder.defineMacro("__OPENCL_VERSION__", "120");
+      else // default to 200
+      {
+        Builder.defineMacro("__OPENCL_VERSION__", "200");
+        CL2 = true;
+      }
+      Builder.defineMacro("__OPENCL_C_VERSION__", "__OPENCL_VERSION__");
+      Builder.defineMacro("NULL", "0");
+
+      if (CL2)
+      {
+        Builder.defineMacro("ATOMIC_VAR_INIT(X)", "X");
+        Builder.defineMacro("ATOMIC_FLAG_INIT", "0");
+      }
+
+      Builder.defineMacro("FLT_DIG", "6");
+      Builder.defineMacro("FLT_MANT_DIG", "24");
+      Builder.defineMacro("FLT_MAX_10_EXP", "+38");
+      Builder.defineMacro("FLT_MAX_EXP", "+128");
+      Builder.defineMacro("FLT_MIN_10_EXP", "-37");
+      Builder.defineMacro("FLT_MIN_EXP", "-125");
+      Builder.defineMacro("FLT_RADIX", "2");
+      Builder.defineMacro("FLT_MAX", "(0x1.fffffep127f)");
+      Builder.defineMacro("FLT_MIN", "0x1.0p-126f");
+      Builder.defineMacro("FLT_EPSILON", "0x1.0p-23f");
+      Builder.defineMacro("MAXFLOAT", "FLT_MAX");
+      Builder.defineMacro("INFINITY", "(1.0f/0.0f)");
+      Builder.defineMacro("HUGE_VALF", "INFINITY");
+      Builder.defineMacro("NAN", "(INFINITY*0.0f)");
+
+      Builder.defineMacro("M_E_F",       "0x1.5bf0a8p+1f");
+      Builder.defineMacro("M_LOG2E_F",   "0x1.715476p+0f");
+      Builder.defineMacro("M_LOG10E_F",  "0x1.bcb7b2p-2f");
+      Builder.defineMacro("M_LN2_F",     "0x1.62e43p-1f");
+      Builder.defineMacro("M_LN10_F",    "0x1.26bb1cp+1f");
+      Builder.defineMacro("M_PI_F",      "0x1.921fb6p+1f");
+      Builder.defineMacro("M_PI_2_F",    "0x1.921fb6p+0f");
+      Builder.defineMacro("M_PI_4_F",    "0x1.921fb6p-1f");
+      Builder.defineMacro("M_1_PI_F",    "0x1.45f306p-2f");
+      Builder.defineMacro("M_2_PI_F",    "0x1.45f306p-1f");
+      Builder.defineMacro("M_2_SQRTPI_F","0x1.20dd76p+0f");
+      Builder.defineMacro("M_SQRT2_F",   "0x1.6a09e6p+0f");
+      Builder.defineMacro("M_SQRT1_2_F", "0x1.6a09e6p-1f");
+
+      Builder.defineMacro("CHAR_BIT", "8");
+      Builder.defineMacro("CHAR_MAX", "SCHAR_MAX");
+      Builder.defineMacro("CHAR_MIN", "SCHAR_MIN");
+      Builder.defineMacro("INT_MAX", "2147483647");
+      Builder.defineMacro("INT_MIN", "(-2147483647 - 1)");
+      Builder.defineMacro("LONG_MAX", "0x7fffffffffffffffL");
+      Builder.defineMacro("LONG_MIN", "(-0x7fffffffffffffffL - 1)");
+      Builder.defineMacro("SCHAR_MAX", "127");
+      Builder.defineMacro("SCHAR_MIN", "(-127 - 1)");
+      Builder.defineMacro("SHRT_MAX", "32767");
+      Builder.defineMacro("SHRT_MIN", "(-32767 - 1)");
+      Builder.defineMacro("UCHAR_MAX", "255");
+      Builder.defineMacro("USHRT_MAX", "65535");
+      Builder.defineMacro("UINT_MAX", "0xffffffff");
+      Builder.defineMacro("ULONG_MAX", "0xffffffffffffffffUL");
+      Builder.defineMacro("FP_ILOGB0", "INT_MIN");
+      Builder.defineMacro("FP_ILOGBNAN", "INT_MAX");
+
+      /* sampler_t */
+      Builder.defineMacro("CLK_NORMALIZED_COORDS_FALSE", "0");
+      Builder.defineMacro("CLK_NORMALIZED_COORDS_TRUE",  "1");
+      Builder.defineMacro("CLK_ADDRESS_NONE",            "0");
+      Builder.defineMacro("CLK_ADDRESS_CLAMP_TO_EDGE",   "2");
+      Builder.defineMacro("CLK_ADDRESS_CLAMP",           "4");
+      Builder.defineMacro("CLK_ADDRESS_REPEAT",          "6");
+      Builder.defineMacro("CLK_ADDRESS_MIRRORED_REPEAT", "8");
+      Builder.defineMacro("CLK_FILTER_NEAREST",          "0x10");
+      Builder.defineMacro("CLK_FILTER_LINEAR",           "0x20");
+
+      /* image_channel_data_type */
+      Builder.defineMacro("CLK_SNORM_INT8",      "0x10D0");
+      Builder.defineMacro("CLK_SNORM_INT16",     "0x10D1");
+      Builder.defineMacro("CLK_UNORM_INT8",      "0x10D2");
+      Builder.defineMacro("CLK_UNORM_INT16",     "0x10D3");
+      Builder.defineMacro("CLK_UNORM_SHORT_565", "0x10D4");
+      Builder.defineMacro("CLK_UNORM_SHORT_555", "0x10D5");
+      Builder.defineMacro("CLK_SHORT_101010",    "0x10D6");
+      Builder.defineMacro("CLK_SIGNED_INT8",     "0x10D7");
+      Builder.defineMacro("CLK_SIGNED_INT16",    "0x10D8");
+      Builder.defineMacro("CLK_SIGNED_INT32",    "0x10D9");
+      Builder.defineMacro("CLK_UNSIGNED_INT8",   "0x10DA");
+      Builder.defineMacro("CLK_UNSIGNED_INT16",  "0x10DB");
+      Builder.defineMacro("CLK_UNSIGNED_INT32",  "0x10DC");
+      Builder.defineMacro("CLK_HALF_FLOAT",      "0x10DD");
+      Builder.defineMacro("CLK_FLOAT",           "0x10DE");
+      Builder.defineMacro("CLK_UNORM_INT24",     "0x10DF");
+      Builder.defineMacro("CLK_UNORM_INT_101010_2", "0x10E0");
+
+      /* image_channel_order */
+      Builder.defineMacro("CLK_R",         "0x10B0");
+      Builder.defineMacro("CLK_A",         "0x10B1");
+      Builder.defineMacro("CLK_RG",        "0x10B2");
+      Builder.defineMacro("CLK_RA",        "0x10B3");
+      Builder.defineMacro("CLK_RGB",       "0x10B4");
+      Builder.defineMacro("CLK_RGBA",      "0x10B5");
+      Builder.defineMacro("CLK_BGRA",      "0x10B6");
+      Builder.defineMacro("CLK_ARGB",      "0x10B7");
+      Builder.defineMacro("CLK_INTENSITY", "0x10B8");
+      Builder.defineMacro("CLK_LUMINANCE", "0x10B9");
+      Builder.defineMacro("CLK_Rx",        "0x10BA");
+      Builder.defineMacro("CLK_RGx",       "0x10BB");
+      Builder.defineMacro("CLK_RGBx",      "0x10BC");
+      Builder.defineMacro("CLK_DEPTH",     "0x10BD");
+      Builder.defineMacro("CLK_DEPTH_STENCIL", "0x10BE");
+      Builder.defineMacro("CLK_sRGB",      "0x10BF");
+      Builder.defineMacro("CLK_sRGBx",     "0x10C0");
+      Builder.defineMacro("CLK_sRGBA",     "0x10C1");
+      Builder.defineMacro("CLK_sBGRA",     "0x10C2");
+      Builder.defineMacro("CLK_ABGR",      "0x10C3");
+
+      /* opencl extensions */
+      Builder.defineMacro("cl_khr_byte_addressable_store",         "1");
+      Builder.defineMacro("cl_khr_global_int32_base_atomics",      "1");
+      Builder.defineMacro("cl_khr_global_int32_extended_atomics",  "1");
+      Builder.defineMacro("cl_khr_local_int32_base_atomics",       "1");
+      Builder.defineMacro("cl_khr_local_int32_extended_atomics",   "1");
+      Builder.defineMacro("cles_khr_int64",                        "1");
+      Builder.defineMacro("cl_khr_3d_image_writes",                "1");
+    }
+    void getTargetBuiltins(const Builtin::Info*&,
+                           unsigned&) const override {}
+    const char *getClobbers() const override {return "";}
+
+    void getGCCRegNames(const char * const *&,
+                        unsigned&) const override {}
+    bool validateAsmConstraint(const char *&,
+                               TargetInfo::ConstraintInfo &) const override {
+      return true;
+    }
+    void getGCCRegAliases(const GCCRegAlias*& Aliases,
+                          unsigned& NumAliases) const override {
+      // No aliases.
+      Aliases = nullptr;
+      NumAliases = 0;
+    }
+    BuiltinVaListKind getBuiltinVaListKind() const override {
+      return TargetInfo::CharPtrBuiltinVaList;
+    }
+  };
+} // end anonymous namespace.
+
   class MSP430TargetInfo : public TargetInfo {
     static const char * const GCCRegNames[];
   public:
@@ -5945,6 +6172,7 @@ validateAsmConstraint(const char *&Name,
       5, // opencl_constant
       // FIXME: generic has to be added to the target
       0, // opencl_generic
+      0, // opencl_private
       0, // cuda_device
       0, // cuda_constant
       0  // cuda_shared
@@ -6794,6 +7022,7 @@ namespace {
     3,    // opencl_local
     2,    // opencl_constant
     4,    // opencl_generic
+    0,    // opencl_private
     0,    // cuda_device
     0,    // cuda_constant
     0     // cuda_shared
@@ -7267,6 +7496,12 @@ static TargetInfo *AllocateTarget(const llvm::Triple &Triple) {
   case llvm::Triple::tce:
     return new TCETargetInfo(Triple);
 
+  case llvm::Triple::usc:
+    return new USCTargetInfo(Triple);
+
+  case llvm::Triple::usc64:
+    return new USCTargetInfo(Triple);
+
   case llvm::Triple::x86:
     if (Triple.isOSDarwin())
       return new DarwinI386TargetInfo(Triple);
diff --git lib/CodeGen/BackendUtil.cpp lib/CodeGen/BackendUtil.cpp
index afcb9e5..8a5f120 100644
--- a/tools/clang/lib/CodeGen/BackendUtil.cpp
+++ b/tools/clang/lib/CodeGen/BackendUtil.cpp
@@ -152,18 +152,12 @@ private:
 }
 
 static void addObjCARCAPElimPass(const PassManagerBuilder &Builder, PassManagerBase &PM) {
-  if (Builder.OptLevel > 0)
-    PM.add(createObjCARCAPElimPass());
 }
 
 static void addObjCARCExpandPass(const PassManagerBuilder &Builder, PassManagerBase &PM) {
-  if (Builder.OptLevel > 0)
-    PM.add(createObjCARCExpandPass());
 }
 
 static void addObjCARCOptPass(const PassManagerBuilder &Builder, PassManagerBase &PM) {
-  if (Builder.OptLevel > 0)
-    PM.add(createObjCARCOptPass());
 }
 
 static void addSampleProfileLoaderPass(const PassManagerBuilder &Builder,
@@ -580,8 +574,6 @@ bool EmitAssemblyHelper::AddEmitPasses(BackendAction Action,
   // Add ObjC ARC final-cleanup optimizations. This is done as part of the
   // "codegen" passes so that it isn't run multiple times when there is
   // inlining happening.
-  if (CodeGenOpts.OptimizationLevel > 0)
-    PM->add(createObjCARCContractPass());
 
   if (TM->addPassesToEmitFile(*PM, OS, CGFT,
                               /*DisableVerify=*/!CodeGenOpts.VerifyModule)) {
@@ -622,6 +614,11 @@ void EmitAssemblyHelper::EmitAssembly(BackendAction Action,
         createPrintModulePass(*OS, "", CodeGenOpts.EmitLLVMUseLists));
     break;
 
+  case Backend_EmitMCNull:
+    if (!AddEmitPasses(Action, *OS))
+      return;
+    break;
+
   default:
     if (!AddEmitPasses(Action, *OS))
       return;
@@ -663,7 +660,7 @@ void clang::EmitBackendOutput(DiagnosticsEngine &Diags,
   EmitAssemblyHelper AsmHelper(Diags, CGOpts, TOpts, LOpts, M);
 
   AsmHelper.EmitAssembly(Action, OS);
-
+#if 0  // We sometimes provide an incomplete description of the layout
   // If an optional clang TargetInfo description string was passed in, use it to
   // verify the LLVM TargetMachine's DataLayout.
   if (AsmHelper.TM && !TDesc.empty()) {
@@ -676,4 +673,5 @@ void clang::EmitBackendOutput(DiagnosticsEngine &Diags,
       Diags.Report(DiagID) << DLDesc << TDesc;
     }
   }
+#endif
 }
diff --git lib/CodeGen/CGDebugInfo.cpp lib/CodeGen/CGDebugInfo.cpp
index 93a2287..3cec817 100644
--- a/tools/clang/lib/CodeGen/CGDebugInfo.cpp
+++ b/tools/clang/lib/CodeGen/CGDebugInfo.cpp
@@ -438,6 +438,24 @@ llvm::DIType *CGDebugInfo::CreateType(const BuiltinType *BT) {
   case BuiltinType::OCLImage2dArray:
     return getOrCreateStructPtrType("opencl_image2d_array_t",
                                     OCLImage2dArrayDITy);
+  case BuiltinType::OCLImage2dDepth:
+    return getOrCreateStructPtrType("opencl_image2d_depth_t",
+                                    OCLImage2dDepthDITy);
+  case BuiltinType::OCLImage2dArrayDepth:
+    return getOrCreateStructPtrType("opencl_image2d_array_depth_t",
+                                    OCLImage2dArrayDepthDITy);
+  case BuiltinType::OCLImage2dMSAA:
+    return getOrCreateStructPtrType("opencl_image2d_msaa_t",
+                                    OCLImage2dMSAADITy);
+  case BuiltinType::OCLImage2dArrayMSAA:
+    return getOrCreateStructPtrType("opencl_image2d_array_msaa_t",
+                                    OCLImage2dArrayMSAADITy);
+  case BuiltinType::OCLImage2dMSAADepth:
+    return getOrCreateStructPtrType("opencl_image2d_msaa_depth_t",
+                                    OCLImage2dMSAADepthDITy);
+  case BuiltinType::OCLImage2dArrayMSAADepth:
+    return getOrCreateStructPtrType("opencl_image2d_array_msaa_depth_t",
+                                    OCLImage2dArrayMSAADepthDITy);
   case BuiltinType::OCLImage3d:
     return getOrCreateStructPtrType("opencl_image3d_t", OCLImage3dDITy);
   case BuiltinType::OCLSampler:
@@ -446,7 +464,14 @@ llvm::DIType *CGDebugInfo::CreateType(const BuiltinType *BT) {
         CGM.getContext().getTypeAlign(BT), llvm::dwarf::DW_ATE_unsigned);
   case BuiltinType::OCLEvent:
     return getOrCreateStructPtrType("opencl_event_t", OCLEventDITy);
-
+  case BuiltinType::OCLClkEvent:
+    return getOrCreateStructPtrType("opencl_clk_event_t", OCLClkEventDITy);
+  case BuiltinType::OCLQueue:
+    return getOrCreateStructPtrType("opencl_queue_t", OCLQueueDITy);
+  case BuiltinType::OCLNDRange:
+    return getOrCreateStructPtrType("opencl_ndrange_t", OCLNDRangeDITy);
+  case BuiltinType::OCLReserveID:
+    return getOrCreateStructPtrType("opencl_reserve_id_t", OCLReserveIDDITy);
   case BuiltinType::UChar:
   case BuiltinType::Char_U:
     Encoding = llvm::dwarf::DW_ATE_unsigned_char;
@@ -1906,6 +1931,13 @@ llvm::DIType *CGDebugInfo::CreateType(const AtomicType *Ty, llvm::DIFile *U) {
   return getOrCreateType(Ty->getValueType(), U);
 }
 
+llvm::DIType *CGDebugInfo::CreateType(const PipeType *Ty, llvm::DIFile *U) {
+  // Ignore the pipe wrapping
+  // FIXME: What is the correct representation?
+  return getOrCreateType(Ty->getValueType(), U);
+}
+
+/// CreateEnumType - get enumeration type.
 llvm::DIType *CGDebugInfo::CreateEnumType(const EnumType *Ty) {
   const EnumDecl *ED = Ty->getDecl();
   uint64_t Size = 0;
@@ -2156,6 +2188,9 @@ llvm::DIType *CGDebugInfo::CreateTypeNode(QualType Ty, llvm::DIFile *Unit) {
   case Type::Atomic:
     return CreateType(cast<AtomicType>(Ty), Unit);
 
+  case Type::Pipe:
+    return CreateType(cast<PipeType>(Ty), Unit);
+
   case Type::TemplateSpecialization:
     return CreateType(cast<TemplateSpecializationType>(Ty), Unit);
 
diff --git lib/CodeGen/CGDebugInfo.h lib/CodeGen/CGDebugInfo.h
index 82680a8..76939e0 100644
--- a/tools/clang/lib/CodeGen/CGDebugInfo.h
+++ b/tools/clang/lib/CodeGen/CGDebugInfo.h
@@ -63,10 +63,21 @@ class CGDebugInfo {
   llvm::DIType *OCLImage1dBufferDITy = nullptr;
   llvm::DIType *OCLImage2dDITy = nullptr;
   llvm::DIType *OCLImage2dArrayDITy = nullptr;
+  llvm::DIType *OCLImage2dDepthDITy = nullptr;
+  llvm::DIType *OCLImage2dArrayDepthDITy = nullptr;
+  llvm::DIType *OCLImage2dMSAADITy = nullptr;
+  llvm::DIType *OCLImage2dArrayMSAADITy = nullptr;
+  llvm::DIType *OCLImage2dMSAADepthDITy = nullptr;
+  llvm::DIType *OCLImage2dArrayMSAADepthDITy = nullptr;
   llvm::DIType *OCLImage3dDITy = nullptr;
   llvm::DIType *OCLEventDITy = nullptr;
+  llvm::DIType *OCLClkEventDITy = nullptr;
+  llvm::DIType *OCLQueueDITy = nullptr;
+  llvm::DIType *OCLNDRangeDITy = nullptr;
+  llvm::DIType *OCLReserveIDDITy = nullptr;
+  llvm::DIType *BlockLiteralGeneric = nullptr;
 
-  /// Cache of previously constructed Types.
+  /// TypeCache - Cache of previously constructed Types.
   llvm::DenseMap<const void *, llvm::TrackingMDRef> TypeCache;
 
   struct ObjCInterfaceCacheEntry {
@@ -124,6 +135,7 @@ class CGDebugInfo {
   /// Currently the checksum of an interface includes the number of
   /// ivars and property accessors.
   unsigned Checksum(const ObjCInterfaceDecl *InterfaceDecl);
+
   llvm::DIType *CreateType(const BuiltinType *Ty);
   llvm::DIType *CreateType(const ComplexType *Ty);
   llvm::DIType *CreateQualifiedType(QualType Ty, llvm::DIFile *Fg);
@@ -152,6 +164,7 @@ class CGDebugInfo {
   llvm::DIType *CreateType(const RValueReferenceType *Ty, llvm::DIFile *Unit);
   llvm::DIType *CreateType(const MemberPointerType *Ty, llvm::DIFile *F);
   llvm::DIType *CreateType(const AtomicType *Ty, llvm::DIFile *F);
+  llvm::DIType *CreateType(const PipeType *Ty, llvm::DIFile *F);
   /// Get enumeration type.
   llvm::DIType *CreateEnumType(const EnumType *Ty);
   llvm::DIType *CreateTypeDefinition(const EnumType *Ty);
diff --git lib/CodeGen/CGDecl.cpp lib/CodeGen/CGDecl.cpp
index 96aa8c6..87ade1e 100644
--- a/tools/clang/lib/CodeGen/CGDecl.cpp
+++ b/tools/clang/lib/CodeGen/CGDecl.cpp
@@ -827,6 +827,7 @@ static void emitStoresForInitAfterMemset(llvm::Constant *Init, llvm::Value *Loc,
 /// zeros, or mostly zeros and large.
 static bool shouldUseMemSetPlusStoresToInitialize(llvm::Constant *Init,
                                                   uint64_t GlobalSize) {
+#if 0
   // If a global is all zeros, always use a memset.
   if (isa<llvm::ConstantAggregateZero>(Init)) return true;
 
@@ -839,6 +840,8 @@ static bool shouldUseMemSetPlusStoresToInitialize(llvm::Constant *Init,
 
   return GlobalSize > SizeLimit &&
          canEmitInitWithFewStoresAfterMemset(Init, StoreBudget);
+#endif
+  return false;
 }
 
 /// EmitAutoVarDecl - Emit code and set up an entry in LocalDeclMap for a
diff --git lib/CodeGen/CGExprConstant.cpp lib/CodeGen/CGExprConstant.cpp
index a15c151..645e60a 100644
--- a/tools/clang/lib/CodeGen/CGExprConstant.cpp
+++ b/tools/clang/lib/CodeGen/CGExprConstant.cpp
@@ -701,9 +701,13 @@ public:
     case CK_CopyAndAutoreleaseBlockObject:
       return nullptr;
 
+    // We have to handle bitcasts here to handle event_t casts
+    case CK_BitCast:
+      if (C->getType() == destType) return C;
+      return llvm::ConstantExpr::getBitCast(C, destType);
+
     // These don't need to be handled here because Evaluate knows how to
     // evaluate them in the cases where they can be folded.
-    case CK_BitCast:
     case CK_ToVoid:
     case CK_Dynamic:
     case CK_LValueBitCast:
diff --git lib/CodeGen/CGExprScalar.cpp lib/CodeGen/CGExprScalar.cpp
index 74f6019..f3f9f97 100644
--- a/tools/clang/lib/CodeGen/CGExprScalar.cpp
+++ b/tools/clang/lib/CodeGen/CGExprScalar.cpp
@@ -816,6 +816,37 @@ Value *ScalarExprEmitter::EmitScalarConversion(Value *Src, QualType SrcType,
     return Builder.CreateVectorSplat(NumElements, Elt, "splat");
   }
 
+  // Vector to vector conversions are done component-wise 
+  if (isa<llvm::VectorType>(Src->getType()) &&
+      isa<llvm::VectorType>(DstTy)) {
+    const llvm::VectorType *DstVecTy = cast<llvm::VectorType>(DstTy);
+    const llvm::VectorType *SrcVecTy = cast<llvm::VectorType>(Src->getType());
+
+    if (SrcVecTy->getNumElements() == DstVecTy->getNumElements()) {
+      unsigned int i = 0;
+
+      /* Get the source and destination element types */
+      QualType SrcElemTy = SrcType->getAs<ExtVectorType>()->getElementType();
+      QualType DstElemTy = DstType->getAs<ExtVectorType>()->getElementType();
+
+      /* Create a new vector */
+      llvm::Value *UnV = llvm::UndefValue::get(DstTy);
+
+      for (i = 0; i < DstVecTy->getNumElements(); i++) {
+        llvm::Value *Idx = llvm::ConstantInt::get(llvm::Type::getInt32Ty(VMContext), i);
+
+        /* Extract the i-th element */
+        llvm::Value *SrcElem = Builder.CreateExtractElement(Src, Idx);
+        llvm::Value *DstElem = EmitScalarConversion(SrcElem, SrcElemTy, DstElemTy);
+
+        UnV = Builder.CreateInsertElement(UnV, DstElem, Idx, "tmp");
+      }
+
+      return UnV;
+    }
+  }
+
+
   // Allow bitcast from vector to integer/fp of the same size.
   if (isa<llvm::VectorType>(SrcTy) ||
       isa<llvm::VectorType>(DstTy))
@@ -1391,8 +1422,9 @@ Value *ScalarExprEmitter::VisitCastExpr(CastExpr *CE) {
     llvm::Type *DstTy = ConvertType(DestTy);
     if (SrcTy->isPtrOrPtrVectorTy() && DstTy->isPtrOrPtrVectorTy() &&
         SrcTy->getPointerAddressSpace() != DstTy->getPointerAddressSpace()) {
-      llvm_unreachable("wrong cast for pointers in different address spaces"
-                       "(must be an address space cast)!");
+      unsigned DstAS = DstTy->getPointerAddressSpace();
+      llvm::Type* elemTy = SrcTy->getPointerElementType();
+      Src = Builder.CreateAddrSpaceCast(Src, elemTy->getPointerTo(DstAS));
     }
 
     if (CGF.SanOpts.has(SanitizerKind::CFIUnrelatedCast)) {
@@ -1407,7 +1439,7 @@ Value *ScalarExprEmitter::VisitCastExpr(CastExpr *CE) {
   }
   case CK_AddressSpaceConversion: {
     Value *Src = Visit(const_cast<Expr*>(E));
-    return Builder.CreateAddrSpaceCast(Src, ConvertType(DestTy));
+    return Builder.CreatePointerBitCastOrAddrSpaceCast(Src, ConvertType(DestTy));
   }
   case CK_AtomicToNonAtomic:
   case CK_NonAtomicToAtomic:
diff --git lib/CodeGen/CGOpenCLRuntime.cpp lib/CodeGen/CGOpenCLRuntime.cpp
index 079ef72..e60f025 100644
--- a/tools/clang/lib/CodeGen/CGOpenCLRuntime.cpp
+++ b/tools/clang/lib/CodeGen/CGOpenCLRuntime.cpp
@@ -55,6 +55,28 @@ llvm::Type *CGOpenCLRuntime::convertOpenCLSpecificType(const Type *T) {
   case BuiltinType::OCLImage2dArray:
     return llvm::PointerType::get(llvm::StructType::create(
                            Ctx, "opencl.image2d_array_t"), ImgAddrSpc);
+  case BuiltinType::OCLImage2dDepth:
+    return llvm::PointerType::get(llvm::StructType::create(
+                           Ctx, "opencl.image2d_depth_t"), ImgAddrSpc);
+  case BuiltinType::OCLImage2dArrayDepth:
+    return llvm::PointerType::get(llvm::StructType::create(
+                           Ctx, "opencl.image2d_array_depth_t"),
+                           ImgAddrSpc);
+  case BuiltinType::OCLImage2dMSAA:
+    return llvm::PointerType::get(llvm::StructType::create(
+                           Ctx, "opencl.image2d_msaa_t"), ImgAddrSpc);
+  case BuiltinType::OCLImage2dArrayMSAA:
+    return llvm::PointerType::get(llvm::StructType::create(
+                           Ctx, "opencl.image2d_array_msaa_t"),
+                           ImgAddrSpc);
+  case BuiltinType::OCLImage2dMSAADepth:
+    return llvm::PointerType::get(llvm::StructType::create(
+                           Ctx, "opencl.image2d_msaa_depth_t"),
+                           ImgAddrSpc);
+  case BuiltinType::OCLImage2dArrayMSAADepth:
+    return llvm::PointerType::get(llvm::StructType::create(
+                           Ctx, "opencl.image2d_array_msaa_depth_t"),
+                           ImgAddrSpc);
   case BuiltinType::OCLImage3d:
     return llvm::PointerType::get(llvm::StructType::create(
                            Ctx, "opencl.image3d_t"), ImgAddrSpc);
@@ -63,5 +85,16 @@ llvm::Type *CGOpenCLRuntime::convertOpenCLSpecificType(const Type *T) {
   case BuiltinType::OCLEvent:
     return llvm::PointerType::get(llvm::StructType::create(
                            Ctx, "opencl.event_t"), 0);
+  case BuiltinType::OCLClkEvent:
+    return llvm::PointerType::get(llvm::StructType::create(
+                           Ctx, "opencl.clk_event_t"), 0);
+  case BuiltinType::OCLQueue:
+    return llvm::PointerType::get(llvm::StructType::create(
+                           Ctx, "opencl.queue_t"), 0);
+  case BuiltinType::OCLNDRange:
+    return llvm::PointerType::get(llvm::StructType::create(
+                           Ctx, "opencl.ndrange_t"), 0);
+  case BuiltinType::OCLReserveID:
+    return llvm::IntegerType::get(Ctx, 32);
   }
 }
diff --git lib/CodeGen/CodeGenFunction.cpp lib/CodeGen/CodeGenFunction.cpp
index ec3c75c..2f6e299 100644
--- a/tools/clang/lib/CodeGen/CodeGenFunction.cpp
+++ b/tools/clang/lib/CodeGen/CodeGenFunction.cpp
@@ -158,6 +158,10 @@ TypeEvaluationKind CodeGenFunction::getEvaluationKind(QualType type) {
     case Type::Atomic:
       type = cast<AtomicType>(type)->getValueType();
       continue;
+    // We treat pipe values as aggregate types, so that they are passed byval (with pointer).
+    case Type::Pipe:
+      return TEK_Aggregate;
+      continue;
     }
     llvm_unreachable("unknown type kind!");
   }
@@ -496,9 +500,10 @@ static void GenOpenCLArgMetadata(const FunctionDecl *FD, llvm::Function *Fn,
       const OpenCLImageAccessAttr *A = parm->getAttr<OpenCLImageAccessAttr>();
       if (A && A->isWriteOnly())
         accessQuals.push_back(llvm::MDString::get(Context, "write_only"));
+      else if (A && A->isReadWrite())
+        accessQuals.push_back(llvm::MDString::get(Context, "read_write"));
       else
         accessQuals.push_back(llvm::MDString::get(Context, "read_only"));
-      // FIXME: what about read_write?
     } else
       accessQuals.push_back(llvm::MDString::get(Context, "none"));
 
@@ -1645,6 +1650,9 @@ void CodeGenFunction::EmitVariablyModifiedType(QualType type) {
     case Type::Atomic:
       type = cast<AtomicType>(ty)->getValueType();
       break;
+    case Type::Pipe:
+      type = cast<PipeType>(ty)->getValueType();
+      break;
     }
   } while (type->isVariablyModifiedType());
 }
diff --git lib/CodeGen/CodeGenTypes.cpp lib/CodeGen/CodeGenTypes.cpp
index a4a8654..0d15d02 100644
--- a/tools/clang/lib/CodeGen/CodeGenTypes.cpp
+++ b/tools/clang/lib/CodeGen/CodeGenTypes.cpp
@@ -389,9 +389,19 @@ llvm::Type *CodeGenTypes::ConvertType(QualType T) {
     case BuiltinType::OCLImage1dBuffer:
     case BuiltinType::OCLImage2d:
     case BuiltinType::OCLImage2dArray:
+    case BuiltinType::OCLImage2dDepth:
+    case BuiltinType::OCLImage2dArrayDepth:
+    case BuiltinType::OCLImage2dMSAA:
+    case BuiltinType::OCLImage2dArrayMSAA:
+    case BuiltinType::OCLImage2dMSAADepth:
+    case BuiltinType::OCLImage2dArrayMSAADepth:
     case BuiltinType::OCLImage3d:
     case BuiltinType::OCLSampler:
     case BuiltinType::OCLEvent:
+    case BuiltinType::OCLClkEvent:
+    case BuiltinType::OCLQueue:
+    case BuiltinType::OCLNDRange:
+    case BuiltinType::OCLReserveID:
       ResultType = CGM.getOpenCLRuntime().convertOpenCLSpecificType(Ty);
       break;
     
@@ -615,6 +625,11 @@ llvm::Type *CodeGenTypes::ConvertType(QualType T) {
     }
     break;
   }
+  case Type::Pipe: {
+    QualType valueType = cast<PipeType>(Ty)->getValueType();
+    ResultType = ConvertTypeForMem(valueType);
+    break;
+  }
   }
   
   assert(ResultType && "Didn't convert a type?");
diff --git lib/CodeGen/ItaniumCXXABI.cpp lib/CodeGen/ItaniumCXXABI.cpp
index 2be9ceb..38e61db 100644
--- a/tools/clang/lib/CodeGen/ItaniumCXXABI.cpp
+++ b/tools/clang/lib/CodeGen/ItaniumCXXABI.cpp
@@ -2346,9 +2346,19 @@ static bool TypeInfoIsInStandardLibrary(const BuiltinType *Ty) {
     case BuiltinType::OCLImage1dBuffer:
     case BuiltinType::OCLImage2d:
     case BuiltinType::OCLImage2dArray:
+    case BuiltinType::OCLImage2dDepth:
+    case BuiltinType::OCLImage2dArrayDepth:
+    case BuiltinType::OCLImage2dMSAA:
+    case BuiltinType::OCLImage2dArrayMSAA:
+    case BuiltinType::OCLImage2dMSAADepth:
+    case BuiltinType::OCLImage2dArrayMSAADepth:
     case BuiltinType::OCLImage3d:
     case BuiltinType::OCLSampler:
     case BuiltinType::OCLEvent:
+    case BuiltinType::OCLClkEvent:
+    case BuiltinType::OCLQueue:
+    case BuiltinType::OCLNDRange:
+    case BuiltinType::OCLReserveID:
       return true;
 
     case BuiltinType::Dependent:
@@ -2535,6 +2545,7 @@ void ItaniumRTTIBuilder::BuildVTablePointer(const Type *Ty) {
   case Type::ExtVector:
   case Type::Complex:
   case Type::Atomic:
+  case Type::Pipe:
   // FIXME: GCC treats block pointers as fundamental types?!
   case Type::BlockPointer:
     // abi::__fundamental_type_info.
@@ -2807,6 +2818,7 @@ llvm::Constant *ItaniumRTTIBuilder::BuildTypeInfo(QualType Ty, bool Force) {
     break;
 
   case Type::Atomic:
+  case Type::Pipe:
     // No fields, at least for the moment.
     break;
   }
diff --git lib/CodeGen/TargetInfo.cpp lib/CodeGen/TargetInfo.cpp
index 48a8b37..6a74c9d 100644
--- a/tools/clang/lib/CodeGen/TargetInfo.cpp
+++ b/tools/clang/lib/CodeGen/TargetInfo.cpp
@@ -4000,7 +4000,12 @@ ABIArgInfo AArch64ABIInfo::classifyArgumentType(QualType Ty) const {
   // Handle illegal vector types here.
   if (isIllegalVectorType(Ty)) {
     uint64_t Size = getContext().getTypeSize(Ty);
-    if (Size <= 32) {
+    // Android promotes <2 x i8> to i16, not i32
+    if (Size <= 16) {
+      llvm::Type *ResType = llvm::Type::getInt16Ty(getVMContext());
+      return ABIArgInfo::getDirect(ResType);
+    }
+    if (Size == 32) {
       llvm::Type *ResType = llvm::Type::getInt32Ty(getVMContext());
       return ABIArgInfo::getDirect(ResType);
     }
@@ -4943,12 +4948,9 @@ bool ARMABIInfo::isIllegalVectorType(QualType Ty) const {
   if (const VectorType *VT = Ty->getAs<VectorType>()) {
     // Check whether VT is legal.
     unsigned NumElements = VT->getNumElements();
-    uint64_t Size = getContext().getTypeSize(VT);
     // NumElements should be power of 2.
-    if ((NumElements & (NumElements - 1)) != 0)
+    if (((NumElements & (NumElements - 1)) != 0) && NumElements != 3)
       return true;
-    // Size should be greater than 32 bits.
-    return Size <= 32;
   }
   return false;
 }
@@ -5000,8 +5002,8 @@ llvm::Value *ARMABIInfo::EmitVAArg(llvm::Value *VAListAddr, QualType Ty,
     TyAlign = std::min(std::max(TyAlign, (uint64_t)4), (uint64_t)8);
   else
     TyAlign = 4;
-  // Use indirect if size of the illegal vector is bigger than 16 bytes.
-  if (isIllegalVectorType(Ty) && Size > 16) {
+  // Use indirect if size of the illegal vector is bigger than 32 bytes.
+  if (isIllegalVectorType(Ty) && Size > 32) {
     IsIndirect = true;
     Size = 4;
     TyAlign = 4;
diff --git lib/Frontend/CompilerInstance.cpp lib/Frontend/CompilerInstance.cpp
index c33b150..412f365 100644
--- a/tools/clang/lib/Frontend/CompilerInstance.cpp
+++ b/tools/clang/lib/Frontend/CompilerInstance.cpp
@@ -393,11 +393,11 @@ void CompilerInstance::createASTContext() {
 // ExternalASTSource
 
 void CompilerInstance::createPCHExternalASTSource(
-    StringRef Path, bool DisablePCHValidation, bool AllowPCHWithCompilerErrors,
+    StringRef Path, llvm::MemoryBuffer *MB, bool DisablePCHValidation, bool AllowPCHWithCompilerErrors,
     void *DeserializationListener, bool OwnDeserializationListener) {
   bool Preamble = getPreprocessorOpts().PrecompiledPreambleBytes.first != 0;
   ModuleManager = createPCHExternalASTSource(
-      Path, getHeaderSearchOpts().Sysroot, DisablePCHValidation,
+      Path, getHeaderSearchOpts().Sysroot, MB, DisablePCHValidation,
       AllowPCHWithCompilerErrors, getPreprocessor(), getASTContext(),
       getPCHContainerReader(), DeserializationListener,
       OwnDeserializationListener, Preamble,
@@ -405,7 +405,8 @@ void CompilerInstance::createPCHExternalASTSource(
 }
 
 IntrusiveRefCntPtr<ASTReader> CompilerInstance::createPCHExternalASTSource(
-    StringRef Path, StringRef Sysroot, bool DisablePCHValidation,
+    StringRef Path, const std::string &Sysroot, llvm::MemoryBuffer *MB,
+    bool DisablePCHValidation,
     bool AllowPCHWithCompilerErrors, Preprocessor &PP, ASTContext &Context,
     const PCHContainerReader &PCHContainerRdr,
     void *DeserializationListener, bool OwnDeserializationListener,
@@ -422,6 +423,12 @@ IntrusiveRefCntPtr<ASTReader> CompilerInstance::createPCHExternalASTSource(
   // eagerly-deserialized declarations may use it.
   Context.setExternalSource(Reader.get());
 
+  if (MB) {
+    std::unique_ptr<llvm::MemoryBuffer> uMB;
+    uMB.reset(MB);
+    Reader->addInMemoryBuffer(Path, std::move(uMB));
+  }
+
   Reader->setDeserializationListener(
       static_cast<ASTDeserializationListener *>(DeserializationListener),
       /*TakeOwnership=*/OwnDeserializationListener);
@@ -780,7 +787,7 @@ bool CompilerInstance::ExecuteAction(FrontendAction &Act) {
 
   // FIXME: Take this as an argument, once all the APIs we used have moved to
   // taking it as an input instead of hard-coding llvm::errs.
-  raw_ostream &OS = llvm::errs();
+  raw_ostream &OS = llvm::nulls();
 
   // Create the target instance.
   setTarget(TargetInfo::CreateTargetInfo(getDiagnostics(),
diff --git lib/Frontend/FrontendAction.cpp lib/Frontend/FrontendAction.cpp
index 3e0f7a1..ed57910 100644
--- a/tools/clang/lib/Frontend/FrontendAction.cpp
+++ b/tools/clang/lib/Frontend/FrontendAction.cpp
@@ -175,6 +175,15 @@ bool FrontendAction::BeginSourceFile(CompilerInstance &CI,
   setCurrentInput(Input);
   setCompilerInstance(&CI);
 
+  if (Input.isBuffer() && Input.getKind() == IK_LLVM_IR) {
+    // Set up the file and source managers, if needed.
+    if (!CI.hasFileManager())
+      CI.createFileManager();
+    if (!CI.hasSourceManager())
+      CI.createSourceManager(CI.getFileManager());
+    return true;
+  }
+
   StringRef InputFile = Input.getFile();
   bool HasBegunSourceFile = false;
   if (!BeginInvocation(CI))
@@ -352,6 +361,7 @@ bool FrontendAction::BeginSourceFile(CompilerInstance &CI,
       }
       CI.createPCHExternalASTSource(
           CI.getPreprocessorOpts().ImplicitPCHInclude,
+          CI.getPreprocessorOpts().ImplicitPCHBuffer,
           CI.getPreprocessorOpts().DisablePCHValidation,
           CI.getPreprocessorOpts().AllowPCHWithCompilerErrors, DeserialListener,
           DeleteDeserialListener);
diff --git lib/Frontend/FrontendOptions.cpp lib/Frontend/FrontendOptions.cpp
index 9ede674..36021ab 100644
--- a/tools/clang/lib/Frontend/FrontendOptions.cpp
+++ b/tools/clang/lib/Frontend/FrontendOptions.cpp
@@ -28,5 +28,5 @@ InputKind FrontendOptions::getInputKindForExtension(StringRef Extension) {
     .Case("cl", IK_OpenCL)
     .Case("cu", IK_CUDA)
     .Cases("ll", "bc", IK_LLVM_IR)
-    .Default(IK_C);
+    .Default(IK_OpenCL);
 }
diff --git lib/Frontend/InitPreprocessor.cpp lib/Frontend/InitPreprocessor.cpp
index 0791494..7a3907e 100644
--- a/tools/clang/lib/Frontend/InitPreprocessor.cpp
+++ b/tools/clang/lib/Frontend/InitPreprocessor.cpp
@@ -99,9 +99,9 @@ static void AddImplicitIncludePTH(MacroBuilder &Builder, Preprocessor &PP,
 static void AddImplicitIncludePCH(MacroBuilder &Builder, Preprocessor &PP,
                                   const PCHContainerReader &PCHContainerRdr,
                                   StringRef ImplicitIncludePCH) {
-  std::string OriginalFile =
-      ASTReader::getOriginalSourceFile(ImplicitIncludePCH, PP.getFileManager(),
-                                       PCHContainerRdr, PP.getDiagnostics());
+  std::string OriginalFile = ImplicitIncludePCH.str();
+//    ASTReader::getOriginalSourceFile(ImplicitIncludePCH, PP.getFileManager(),
+//                                     PP.getDiagnostics());
   if (OriginalFile.empty())
     return;
 
diff --git lib/FrontendTool/ExecuteCompilerInvocation.cpp lib/FrontendTool/ExecuteCompilerInvocation.cpp
index 79cf004..1aba05a 100644
--- a/tools/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp
+++ b/tools/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp
@@ -28,6 +28,7 @@
 #include "llvm/Option/Option.h"
 #include "llvm/Support/DynamicLibrary.h"
 #include "llvm/Support/ErrorHandling.h"
+#include "llvm/IR/LLVMContext.h"
 using namespace clang;
 using namespace llvm::opt;
 
@@ -48,7 +49,7 @@ static FrontendAction *CreateFrontendBaseAction(CompilerInstance &CI) {
   case EmitHTML:               return new HTMLPrintAction();
   case EmitLLVM:               return new EmitLLVMAction();
   case EmitLLVMOnly:           return new EmitLLVMOnlyAction();
-  case EmitCodeGenOnly:        return new EmitCodeGenOnlyAction();
+  case EmitCodeGenOnly:        return new EmitCodeGenOnlyAction(&llvm::getGlobalContext());
   case EmitObj:                return new EmitObjAction();
   case FixIt:                  return new FixItAction();
   case GenerateModule:         return new GenerateModuleAction;
diff --git lib/Index/USRGeneration.cpp lib/Index/USRGeneration.cpp
index 8cdd283..ed70418 100644
--- a/tools/clang/lib/Index/USRGeneration.cpp
+++ b/tools/clang/lib/Index/USRGeneration.cpp
@@ -613,8 +613,18 @@ void USRGenerator::VisitType(QualType T) {
         case BuiltinType::OCLImage1dBuffer:
         case BuiltinType::OCLImage2d:
         case BuiltinType::OCLImage2dArray:
+        case BuiltinType::OCLImage2dDepth:
+        case BuiltinType::OCLImage2dArrayDepth:
+        case BuiltinType::OCLImage2dMSAA:
+        case BuiltinType::OCLImage2dArrayMSAA:
+        case BuiltinType::OCLImage2dMSAADepth:
+        case BuiltinType::OCLImage2dArrayMSAADepth:
         case BuiltinType::OCLImage3d:
         case BuiltinType::OCLEvent:
+        case BuiltinType::OCLClkEvent:
+        case BuiltinType::OCLQueue:
+        case BuiltinType::OCLNDRange:
+        case BuiltinType::OCLReserveID:
         case BuiltinType::OCLSampler:
           IgnoreResults = true;
           return;
diff --git lib/Lex/HeaderSearch.cpp lib/Lex/HeaderSearch.cpp
index 983dc18..a4bb29d 100644
--- a/tools/clang/lib/Lex/HeaderSearch.cpp
+++ b/tools/clang/lib/Lex/HeaderSearch.cpp
@@ -593,7 +593,7 @@ const FileEntry *HeaderSearch::LookupFile(
     *SuggestedModule = ModuleMap::KnownHeader();
     
   // If 'Filename' is absolute, check to see if it exists and no searching.
-  if (llvm::sys::path::is_absolute(Filename)) {
+  if (!Filename.compare("OCLBuiltins") || llvm::sys::path::is_absolute(Filename)) {
     CurDir = nullptr;
 
     // If this was an #include_next "/absolute/file", fail.
diff --git lib/Lex/LiteralSupport.cpp lib/Lex/LiteralSupport.cpp
index aed9164..987c2fa 100644
--- a/tools/clang/lib/Lex/LiteralSupport.cpp
+++ b/tools/clang/lib/Lex/LiteralSupport.cpp
@@ -506,8 +506,10 @@ static void EncodeUCNEscape(const char *ThisTokBegin, const char *&ThisTokBuf,
 ///
 NumericLiteralParser::NumericLiteralParser(StringRef TokSpelling,
                                            SourceLocation TokLoc,
-                                           Preprocessor &PP)
-  : PP(PP), ThisTokBegin(TokSpelling.begin()), ThisTokEnd(TokSpelling.end()) {
+                                           Preprocessor &PP,
+                                           llvm::APFloat::roundingMode Rounding)
+  : PP(PP), ThisTokBegin(TokSpelling.begin()), ThisTokEnd(TokSpelling.end()),
+    Rounding(Rounding) {
 
   // This routine assumes that the range begin/end matches the regex for integer
   // and FP constants (specifically, the 'pp-number' regex), and assumes that
@@ -522,6 +524,7 @@ NumericLiteralParser::NumericLiteralParser(StringRef TokSpelling,
   isLong = false;
   isUnsigned = false;
   isLongLong = false;
+  isHalf = false;
   isFloat = false;
   isImaginary = false;
   MicrosoftInteger = 0;
@@ -579,10 +582,17 @@ NumericLiteralParser::NumericLiteralParser(StringRef TokSpelling,
   // we break out of the loop.
   for (; s != ThisTokEnd; ++s) {
     switch (*s) {
+    case 'h':
+    case 'H':  // FP Suffix for "half"
+      if (!PP.getLangOpts().OpenCL) break; // Only allowed in OpenCL
+      if (!isFPConstant) break;  // Error for integer constant.
+      if (isHalf || isFloat || isLong) break; // FF, LF invalid.
+      isHalf = true;
+      continue;  // Success.
     case 'f':      // FP Suffix for "float"
     case 'F':
       if (!isFPConstant) break;  // Error for integer constant.
-      if (isFloat || isLong) break; // FF, LF invalid.
+      if (isHalf || isFloat || isLong) break; // FF, LF invalid.
       isFloat = true;
       continue;  // Success.
     case 'u':
@@ -594,7 +604,7 @@ NumericLiteralParser::NumericLiteralParser(StringRef TokSpelling,
     case 'l':
     case 'L':
       if (isLong || isLongLong) break;  // Cannot be repeated.
-      if (isFloat) break;               // LF invalid.
+      if (isHalf || isFloat) break;     // LF invalid.
 
       // Check for long long.  The L's need to be adjacent and the same case.
       if (s[1] == s[0]) {
@@ -973,7 +983,7 @@ NumericLiteralParser::GetFloatValue(llvm::APFloat &Result) {
     Str = Buffer;
   }
 
-  return Result.convertFromString(Str, APFloat::rmNearestTiesToEven);
+  return Result.convertFromString(Str, Rounding);
 }
 
 
diff --git lib/Lex/PPDirectives.cpp lib/Lex/PPDirectives.cpp
index ce64538..fb1acc7 100644
--- a/tools/clang/lib/Lex/PPDirectives.cpp
+++ b/tools/clang/lib/Lex/PPDirectives.cpp
@@ -12,6 +12,7 @@
 ///
 //===----------------------------------------------------------------------===//
 
+#include "clang/Lex/PreprocessorOptions.h"
 #include "clang/Lex/Preprocessor.h"
 #include "clang/Basic/FileManager.h"
 #include "clang/Basic/SourceManager.h"
@@ -655,6 +656,15 @@ const FileEntry *Preprocessor::LookupFile(
     }
   }
 
+  // Deal with embedded headers which are stored as MemoryBuffer
+  for (auto I = PPOpts->RemappedFileBuffers.begin(),
+  		E = PPOpts->RemappedFileBuffers.end(); I != E; ++I) {
+    if (!I->first.compare(Filename)) {
+      // Find the file entry of the embedded header
+      return FileMgr.getFile(Filename, /*openFile=*/true);
+    }
+  }
+
   CurDir = CurDirLookup;
 
   if (FromFile) {
diff --git lib/Parse/ParseDecl.cpp lib/Parse/ParseDecl.cpp
index 45878b9..fab2180 100644
--- a/tools/clang/lib/Parse/ParseDecl.cpp
+++ b/tools/clang/lib/Parse/ParseDecl.cpp
@@ -671,7 +671,7 @@ void Parser::ParseBorlandTypeAttributes(ParsedAttributes &attrs) {
   }
 }
 
-void Parser::ParseOpenCLAttributes(ParsedAttributes &attrs) {
+void Parser::ParseOpenCLKernelAttributes(ParsedAttributes &attrs) {
   // Treat these like attributes
   while (Tok.is(tok::kw___kernel)) {
     IdentifierInfo *AttrName = Tok.getIdentifierInfo();
@@ -3075,7 +3075,7 @@ void Parser::ParseDeclarationSpecifiers(DeclSpec &DS,
 
     // OpenCL single token adornments.
     case tok::kw___kernel:
-      ParseOpenCLAttributes(DS.getAttributes());
+      ParseOpenCLKernelAttributes(DS.getAttributes());
       continue;
 
     // Nullability type specifiers.
@@ -3400,6 +3400,16 @@ void Parser::ParseDeclarationSpecifiers(DeclSpec &DS,
       isInvalid = DS.SetTypeQual(DeclSpec::TQ_atomic, Loc, PrevSpec, DiagID,
                                  getLangOpts());
       break;
+    case tok::kw_pipe:
+      if (Actions.getLangOpts().OpenCLVersion < 200) {
+        DiagID = diag::err_opencl_unknown_type_specifier;
+        PrevSpec = Tok.getIdentifierInfo()->getNameStart();
+        isInvalid = true;
+        break;
+      };
+      isInvalid = DS.SetTypeQual(DeclSpec::TQ_pipe, Loc, PrevSpec, DiagID,
+                                 getLangOpts());
+      break;
 
     // OpenCL qualifiers:
     case tok::kw___generic:
@@ -4206,6 +4216,7 @@ bool Parser::isTypeQualifier() const {
   default: return false;
   // type-qualifier
   case tok::kw_const:
+  case tok::kw_pipe:
   case tok::kw_volatile:
   case tok::kw_restrict:
   case tok::kw___private:
@@ -4378,6 +4389,8 @@ bool Parser::isTypeSpecifierQualifier() {
   // C11 _Atomic
   case tok::kw__Atomic:
     return true;
+  case tok::kw_pipe:
+    return true;
   }
 }
 
@@ -4516,6 +4529,9 @@ bool Parser::isDeclarationSpecifier(bool DisambiguatingWithExpression) {
   case tok::kw__Atomic:
     return true;
 
+  case tok::kw_pipe:
+    return true;
+
     // GNU ObjC bizarre protocol extension: <proto1,proto2> with implicit 'id'.
   case tok::less:
     return getLangOpts().ObjC1;
@@ -4733,6 +4749,17 @@ void Parser::ParseTypeQualifierListOpt(DeclSpec &DS, unsigned AttrReqs,
       isInvalid = DS.SetTypeQual(DeclSpec::TQ_atomic, Loc, PrevSpec, DiagID,
                                  getLangOpts());
       break;
+    case tok::kw_pipe:
+      if (Actions.getLangOpts().OpenCLVersion < 200) {
+        DiagID = diag::err_opencl_unknown_type_specifier;
+        PrevSpec = Tok.getIdentifierInfo()->getNameStart();
+        isInvalid = true;
+        break;
+      };
+
+      isInvalid = DS.SetTypeQual(DeclSpec::TQ_pipe, Loc, PrevSpec, DiagID,
+                                 getLangOpts());
+      break;
 
     // OpenCL qualifiers:
     case tok::kw___private:
@@ -5001,6 +5028,9 @@ void Parser::ParseDeclaratorInternal(Declarator &D,
       if (DS.getTypeQualifiers() & DeclSpec::TQ_atomic)
         Diag(DS.getAtomicSpecLoc(),
              diag::err_invalid_reference_qualifier_application) << "_Atomic";
+      if (DS.getTypeQualifiers() & DeclSpec::TQ_pipe)
+        Diag(DS.getPipeSpecLoc(),
+             diag::err_invalid_reference_qualifier_application) << "pipe";
     }
 
     // Recursively parse the declarator.
@@ -6227,7 +6257,6 @@ void Parser::ParseAtomicSpecifier(DeclSpec &DS) {
     Diag(StartLoc, DiagID) << PrevSpec;
 }
 
-
 /// TryAltiVecVectorTokenOutOfLine - Out of line body that should only be called
 /// from TryAltiVecVectorToken.
 bool Parser::TryAltiVecVectorTokenOutOfLine() {
diff --git lib/Parse/ParseDeclCXX.cpp lib/Parse/ParseDeclCXX.cpp
index e347d4e..251a022 100644
--- a/tools/clang/lib/Parse/ParseDeclCXX.cpp
+++ b/tools/clang/lib/Parse/ParseDeclCXX.cpp
@@ -1102,6 +1102,7 @@ bool Parser::isValidAfterTypeSpecifier(bool CouldBeBitfield) {
   case tok::kw_volatile:        // struct foo {...} volatile  x;
   case tok::kw_restrict:        // struct foo {...} restrict  x;
   case tok::kw__Atomic:         // struct foo {...} _Atomic   x;
+  case tok::kw_pipe:            // struct foo {...} pipe      x;
   case tok::kw___unaligned:     // struct foo {...} __unaligned *x;
   // Function specifiers
   // Note, no 'explicit'. An explicit function must be either a conversion
diff --git lib/Parse/ParsePragma.cpp lib/Parse/ParsePragma.cpp
index 892d3c6..f95ec2d 100644
--- a/tools/clang/lib/Parse/ParsePragma.cpp
+++ b/tools/clang/lib/Parse/ParsePragma.cpp
@@ -451,6 +451,15 @@ void Parser::HandlePragmaOpenCLExtension() {
   SourceLocation NameLoc = Tok.getLocation();
   ConsumeToken(); // The annotation token.
 
+  // Unsupported extensions
+  if (ename->isStr("cl_khr_int64_base_atomics") || ename->isStr("cl_khr_int64_extended_atomics") ||
+      ename->isStr("cl_khr_gl_sharing") || ename->isStr("cl_khr_gl_event") ||
+      ename->isStr("cl_khr_d3d10_sharing") ||
+      ename->isStr("cl_khr_fp64")) {
+    PP.Diag(NameLoc, diag::error_ext_opencl_pragma_unsupported) << ename;
+    return;
+  }
+
   OpenCLOptions &f = Actions.getOpenCLOptions();
   // OpenCL 1.1 9.1: "The all variant sets the behavior for all extensions,
   // overriding all previously issued extension directives, but only if the
@@ -1417,7 +1426,7 @@ PragmaOpenCLExtensionHandler::HandlePragma(Preprocessor &PP,
   IdentifierInfo *op = Tok.getIdentifierInfo();
 
   unsigned state;
-  if (op->isStr("enable")) {
+  if (op->isStr("enable") || op->isStr("require")) {
     state = 1;
   } else if (op->isStr("disable")) {
     state = 0;
diff --git lib/Parse/ParseStmt.cpp lib/Parse/ParseStmt.cpp
index b658cef..509ac4d 100644
--- a/tools/clang/lib/Parse/ParseStmt.cpp
+++ b/tools/clang/lib/Parse/ParseStmt.cpp
@@ -102,6 +102,8 @@ Parser::ParseStatementOrDeclaration(StmtVector &Stmts, bool OnlyStatement,
 
   ParsedAttributesWithRange Attrs(AttrFactory);
   MaybeParseCXX11Attributes(Attrs, nullptr, /*MightBeObjCMessageSend*/ true);
+  if (!MaybeParseOpenCLUnrollHintAttribute(Attrs))
+    return StmtError();
 
   StmtResult Res = ParseStatementOrDeclarationAfterAttributes(Stmts,
                                  OnlyStatement, TrailingElseLoc, Attrs);
@@ -2145,3 +2147,19 @@ void Parser::ParseMicrosoftIfExistsStatement(StmtVector &Stmts) {
   }
   Braces.consumeClose();
 }
+
+bool Parser::ParseOpenCLUnrollHintAttribute(ParsedAttributes &Attrs) {
+  MaybeParseGNUAttributes(Attrs);
+
+  if (Attrs.empty())
+    return true;
+
+  if (Attrs.getList()->getKind() != AttributeList::AT_OpenCLUnrollHint)
+    return true;
+
+  if (!(Tok.is(tok::kw_for) || Tok.is(tok::kw_while) || Tok.is(tok::kw_do))) {
+    Diag(Tok, diag::err_opencl_unroll_hint_on_non_loop);
+    return false;
+  }
+  return true;
+}
diff --git lib/Sema/DeclSpec.cpp lib/Sema/DeclSpec.cpp
index 4adbb2b..729148b 100644
--- a/tools/clang/lib/Sema/DeclSpec.cpp
+++ b/tools/clang/lib/Sema/DeclSpec.cpp
@@ -189,6 +189,8 @@ DeclaratorChunk DeclaratorChunk::getFunction(bool hasProto,
                                              TypeResult TrailingReturnType) {
   assert(!(TypeQuals & DeclSpec::TQ_atomic) &&
          "function cannot have _Atomic qualifier");
+  assert(!(TypeQuals & DeclSpec::TQ_pipe) &&
+         "function cannot have pipe qualifier");
 
   DeclaratorChunk I;
   I.Kind                        = Function;
@@ -286,6 +288,7 @@ bool Declarator::isDeclarationOfFunction() const {
   
   switch (DS.getTypeSpecType()) {
     case TST_atomic:
+    case TST_pipe:
     case TST_auto:
     case TST_bool:
     case TST_char:
@@ -475,6 +478,7 @@ const char *DeclSpec::getSpecifierName(DeclSpec::TST T,
   case DeclSpec::TST_underlyingType: return "__underlying_type";
   case DeclSpec::TST_unknown_anytype: return "__unknown_anytype";
   case DeclSpec::TST_atomic: return "_Atomic";
+  case DeclSpec::TST_pipe: return "pipe";
   case DeclSpec::TST_error:       return "(error)";
   }
   llvm_unreachable("Unknown typespec!");
@@ -487,6 +491,7 @@ const char *DeclSpec::getSpecifierName(TQ T) {
   case DeclSpec::TQ_restrict:    return "restrict";
   case DeclSpec::TQ_volatile:    return "volatile";
   case DeclSpec::TQ_atomic:      return "_Atomic";
+  case DeclSpec::TQ_pipe:        return "pipe";
   }
   llvm_unreachable("Unknown typespec!");
 }
@@ -773,6 +778,7 @@ bool DeclSpec::SetTypeQual(TQ T, SourceLocation Loc, const char *&PrevSpec,
   case TQ_restrict: TQ_restrictLoc = Loc; return false;
   case TQ_volatile: TQ_volatileLoc = Loc; return false;
   case TQ_atomic:   TQ_atomicLoc = Loc; return false;
+  case TQ_pipe:     TQ_pipeLoc = Loc; return false;
   }
 
   llvm_unreachable("Unknown type qualifier!");
@@ -938,10 +944,10 @@ void DeclSpec::Finish(DiagnosticsEngine &D, Preprocessor &PP, const PrintingPoli
        TypeSpecSign != TSS_unspecified ||
        TypeAltiVecVector || TypeAltiVecPixel || TypeAltiVecBool ||
        TypeQualifiers)) {
-    const unsigned NumLocs = 8;
+    const unsigned NumLocs = 9;
     SourceLocation ExtraLocs[NumLocs] = {
       TSWLoc, TSCLoc, TSSLoc, AltiVecLoc,
-      TQ_constLoc, TQ_restrictLoc, TQ_volatileLoc, TQ_atomicLoc
+      TQ_constLoc, TQ_restrictLoc, TQ_volatileLoc, TQ_atomicLoc, TQ_pipeLoc
     };
     FixItHint Hints[NumLocs];
     SourceLocation FirstLoc;
diff --git lib/Sema/Sema.cpp lib/Sema/Sema.cpp
index 18d7e9d..28d1ab0 100644
--- a/tools/clang/lib/Sema/Sema.cpp
+++ b/tools/clang/lib/Sema/Sema.cpp
@@ -206,11 +206,27 @@ void Sema::Initialize() {
 
   // Initialize predefined OpenCL types.
   if (PP.getLangOpts().OpenCL) {
+    addImplicitTypedef("uchar", Context.UnsignedCharTy);
+    addImplicitTypedef("ushort", Context.UnsignedShortTy);
+    addImplicitTypedef("uint", Context.UnsignedIntTy);
+    addImplicitTypedef("ulong", Context.UnsignedLongTy);
+
+    addImplicitTypedef("size_t", Context.getSizeType());
+    addImplicitTypedef("ptrdiff_t", Context.getPointerDiffType());
+    addImplicitTypedef("intptr_t", Context.getIntPtrType());
+    addImplicitTypedef("uintptr_t", Context.getUIntPtrType());
+
     addImplicitTypedef("image1d_t", Context.OCLImage1dTy);
     addImplicitTypedef("image1d_array_t", Context.OCLImage1dArrayTy);
     addImplicitTypedef("image1d_buffer_t", Context.OCLImage1dBufferTy);
     addImplicitTypedef("image2d_t", Context.OCLImage2dTy);
     addImplicitTypedef("image2d_array_t", Context.OCLImage2dArrayTy);
+    addImplicitTypedef("image2d_depth_t", Context.OCLImage2dDepthTy);
+    addImplicitTypedef("image2d_array_depth_t", Context.OCLImage2dArrayDepthTy);
+    addImplicitTypedef("image2d_msaa_t", Context.OCLImage2dMSAATy);
+    addImplicitTypedef("image2d_array_msaa_t", Context.OCLImage2dArrayMSAATy);
+    addImplicitTypedef("image2d_msaa_depth_t", Context.OCLImage2dMSAADepthTy);
+    addImplicitTypedef("image2d_array_msaa_depth_t", Context.OCLImage2dArrayMSAADepthTy);
     addImplicitTypedef("image3d_t", Context.OCLImage3dTy);
     addImplicitTypedef("sampler_t", Context.OCLSamplerTy);
     addImplicitTypedef("event_t", Context.OCLEventTy);
@@ -237,6 +253,10 @@ void Sema::Initialize() {
       addImplicitTypedef("atomic_ptrdiff_t",
                          Context.getAtomicType(Context.getPointerDiffType()));
     }
+    addImplicitTypedef("clk_event_t", Context.OCLClkEventTy);
+    addImplicitTypedef("queue_t", Context.OCLQueueTy);
+    addImplicitTypedef("ndrange_t", Context.OCLNDRangeTy);
+    addImplicitTypedef("reserve_id_t", Context.OCLReserveIDTy);
   }
 
   DeclarationName BuiltinVaList = &Context.Idents.get("__builtin_va_list");
diff --git lib/Sema/SemaAttr.cpp lib/Sema/SemaAttr.cpp
index 5a29bad..2e10f3e 100644
--- a/tools/clang/lib/Sema/SemaAttr.cpp
+++ b/tools/clang/lib/Sema/SemaAttr.cpp
@@ -566,9 +566,15 @@ void Sema::ActOnPragmaFPContract(tok::OnOffSwitch OOS) {
   switch (OOS) {
   case tok::OOS_ON:
     FPFeatures.fp_contract = 1;
+    // Store pragma to language option is a temp solution to pass down pragma
+    // flag to compiler backend, because currently clang does not support
+    // multiple pragmas to be used inside a kernel definition. The only supported
+    // behavior is using this pragma preceding all explicit declarations.
+    LangOpts.DisableFPContract = 0;
     break;
   case tok::OOS_OFF:
     FPFeatures.fp_contract = 0; 
+    LangOpts.DisableFPContract = 1;
     break;
   case tok::OOS_DEFAULT:
     FPFeatures.fp_contract = getLangOpts().DefaultFPContract;
diff --git lib/Sema/SemaCast.cpp lib/Sema/SemaCast.cpp
index c0754ba..bbf4b4c 100644
--- a/tools/clang/lib/Sema/SemaCast.cpp
+++ b/tools/clang/lib/Sema/SemaCast.cpp
@@ -2299,6 +2299,16 @@ void CastOperation::CheckCStyleCast() {
       return;
     }
 
+    // Allow OpenCL (event_t) 0
+    if (Self.getLangOpts().OpenCL && DestType->isEventT()) {
+		llvm::APSInt ConstValue;
+      if (SrcExpr.get()->isIntegerConstantExpr(ConstValue, Self.Context)) {
+        if (ConstValue == 0)
+          Kind = CK_IntegralCast;
+          return;
+      }
+    }
+
     // Reject any other conversions to non-scalar types.
     Self.Diag(OpRange.getBegin(), diag::err_typecheck_cond_expect_scalar)
       << DestType << SrcExpr.get()->getSourceRange();
diff --git lib/Sema/SemaCodeComplete.cpp lib/Sema/SemaCodeComplete.cpp
index 8626527..c2fd55b 100644
--- a/tools/clang/lib/Sema/SemaCodeComplete.cpp
+++ b/tools/clang/lib/Sema/SemaCodeComplete.cpp
@@ -3814,6 +3814,9 @@ void Sema::CodeCompleteTypeQualifiers(DeclSpec &DS) {
   if (getLangOpts().C11 &&
       !(DS.getTypeQualifiers() & DeclSpec::TQ_atomic))
     Results.AddResult("_Atomic");
+  if (getLangOpts().OpenCL &&
+      !(DS.getTypeQualifiers() & DeclSpec::TQ_pipe))
+    Results.AddResult("pipe");
   Results.ExitScope();
   HandleCodeCompleteResults(this, CodeCompleter, 
                             Results.getCompletionContext(),
diff --git lib/Sema/SemaDecl.cpp lib/Sema/SemaDecl.cpp
index c694a20..09308d6 100644
--- a/tools/clang/lib/Sema/SemaDecl.cpp
+++ b/tools/clang/lib/Sema/SemaDecl.cpp
@@ -3851,6 +3851,8 @@ Decl *Sema::ParsedFreeStandingDeclSpec(Scope *S, AccessSpecifier AS,
     // Restrict is covered above.
     if (DS.getTypeQualifiers() & DeclSpec::TQ_atomic)
       Diag(DS.getAtomicSpecLoc(), DiagID) << "_Atomic";
+    if (DS.getTypeQualifiers() & DeclSpec::TQ_pipe)
+      Diag(DS.getPipeSpecLoc(), DiagID) << "pipe";
   }
 
   // Warn about ignored type attributes, for example:
@@ -4115,6 +4117,11 @@ Decl *Sema::BuildAnonymousStructOrUnion(Scope *S, DeclSpec &DS,
              diag::ext_anonymous_struct_union_qualified)
           << Record->isUnion() << "_Atomic"
           << FixItHint::CreateRemoval(DS.getAtomicSpecLoc());
+      if (DS.getTypeQualifiers() & DeclSpec::TQ_pipe)
+        Diag(DS.getPipeSpecLoc(),
+             diag::ext_anonymous_struct_union_qualified)
+          << Record->isUnion() << "pipe"
+          << FixItHint::CreateRemoval(DS.getPipeSpecLoc());
 
       DS.ClearTypeQualifiers();
     }
@@ -4523,6 +4530,7 @@ static bool RebuildDeclaratorInCurrentInstantiation(Sema &S, Declarator &D,
 
   DeclSpec &DS = D.getMutableDeclSpec();
   switch (DS.getTypeSpecType()) {
+  case DeclSpec::TST_pipe: llvm_unreachable("cannot rebuild pipe type");
   case DeclSpec::TST_typename:
   case DeclSpec::TST_typeofType:
   case DeclSpec::TST_underlyingType:
@@ -6370,7 +6378,8 @@ void Sema::CheckVariableDeclarationType(VarDecl *NewVD) {
   // This includes arrays of objects with address space qualifiers, but not
   // automatic variables that point to other address spaces.
   // ISO/IEC TR 18037 S5.1.2
-  if (NewVD->hasLocalStorage() && T.getAddressSpace() != 0) {
+  if (NewVD->hasLocalStorage() && T.getAddressSpace() != 0 &&
+      !(getLangOpts().OpenCL && T.getAddressSpace() == LangAS::opencl_private)) {
     Diag(NewVD->getLocation(), diag::err_as_qualified_auto_decl);
     NewVD->setInvalidDecl();
     return;
@@ -6380,15 +6389,25 @@ void Sema::CheckVariableDeclarationType(VarDecl *NewVD) {
   // __constant address space.
   if (getLangOpts().OpenCL && NewVD->isFileVarDecl()
       && T.getAddressSpace() != LangAS::opencl_constant
-      && !T->isSamplerT()){
+      && !T->isSamplerT() && getLangOpts().OpenCLVersion < 200) {
     Diag(NewVD->getLocation(), diag::err_opencl_global_invalid_addr_space);
     NewVD->setInvalidDecl();
     return;
   }
+
+  // OpenCL 2.0 allows global variables declared in the global address space
+  if (getLangOpts().OpenCL && NewVD->isFileVarDecl()
+      && T.getAddressSpace() != LangAS::opencl_constant
+      && T.getAddressSpace() != LangAS::opencl_global
+      && !T->isSamplerT() && getLangOpts().OpenCLVersion >= 200) {
+    Diag(NewVD->getLocation(), diag::err_opencl_global_invalid_addr_space200);
+    NewVD->setInvalidDecl();
+    return;
+  }
   
   // OpenCL v1.2 s6.8 -- The static qualifier is valid only in program
   // scope.
-  if ((getLangOpts().OpenCLVersion >= 120)
+  if ((getLangOpts().OpenCLVersion >= 120 && getLangOpts().OpenCLVersion < 200)
       && NewVD->isStaticLocal()) {
     Diag(NewVD->getLocation(), diag::err_static_function_scope);
     NewVD->setInvalidDecl();
@@ -10322,7 +10341,8 @@ ParmVarDecl *Sema::CheckParameter(DeclContext *DC, SourceLocation StartLoc,
   // duration shall not be qualified by an address-space qualifier."
   // Since all parameters have automatic store duration, they can not have
   // an address space.
-  if (T.getAddressSpace() != 0) {
+  if (T.getAddressSpace() != 0 &&
+      !(getLangOpts().OpenCL && T.getAddressSpace() == LangAS::opencl_private)) {
     // OpenCL allows function arguments declared to be an array of a type
     // to be qualified with an address space.
     if (!(getLangOpts().OpenCL && T->isArrayType())) {
@@ -11029,6 +11049,8 @@ NamedDecl *Sema::ImplicitlyDefineFunction(SourceLocation Loc,
   unsigned diag_id;
   if (II.getName().startswith("__builtin_"))
     diag_id = diag::warn_builtin_unknown;
+  else if (getLangOpts().OpenCL)
+    diag_id = diag::err_implicit_function_decl;
   else if (getLangOpts().C99)
     diag_id = diag::ext_implicit_function_decl;
   else
diff --git lib/Sema/SemaDeclCXX.cpp lib/Sema/SemaDeclCXX.cpp
index 0d7cbf4..661f490 100644
--- a/tools/clang/lib/Sema/SemaDeclCXX.cpp
+++ b/tools/clang/lib/Sema/SemaDeclCXX.cpp
@@ -4594,6 +4594,7 @@ struct CheckAbstractUsage {
   CheckPolymorphic(MemberPointerTypeLoc)
   CheckPolymorphic(BlockPointerTypeLoc)
   CheckPolymorphic(AtomicTypeLoc)
+  CheckPolymorphic(PipeTypeLoc)
 
   /// Handle all the types we haven't given a more specific
   /// implementation for above.
@@ -6669,7 +6670,8 @@ QualType Sema::CheckConstructorDeclarator(Declarator &D, QualType R,
         diag::err_constructor_return_type, TypeQuals, SourceLocation(),
         D.getDeclSpec().getConstSpecLoc(), D.getDeclSpec().getVolatileSpecLoc(),
         D.getDeclSpec().getRestrictSpecLoc(),
-        D.getDeclSpec().getAtomicSpecLoc());
+        D.getDeclSpec().getAtomicSpecLoc(),
+        D.getDeclSpec().getPipeSpecLoc());
     D.setInvalidType();
   }
 
@@ -6839,7 +6841,8 @@ QualType Sema::CheckDestructorDeclarator(Declarator &D, QualType R,
                                 D.getDeclSpec().getConstSpecLoc(),
                                 D.getDeclSpec().getVolatileSpecLoc(),
                                 D.getDeclSpec().getRestrictSpecLoc(),
-                                D.getDeclSpec().getAtomicSpecLoc());
+                                D.getDeclSpec().getAtomicSpecLoc(),
+                                D.getDeclSpec().getPipeSpecLoc());
       D.setInvalidType();
     }
   }
diff --git lib/Sema/SemaExpr.cpp lib/Sema/SemaExpr.cpp
index 6499cb5..2dce19a 100644
--- a/tools/clang/lib/Sema/SemaExpr.cpp
+++ b/tools/clang/lib/Sema/SemaExpr.cpp
@@ -744,7 +744,7 @@ ExprResult Sema::UsualUnaryConversions(Expr *E) {
   assert(!Ty.isNull() && "UsualUnaryConversions - missing type");
 
   // Half FP have to be promoted to float unless it is natively supported
-  if (Ty->isHalfType() && !getLangOpts().NativeHalfType)
+  if (Ty->isHalfType() && getOpenCLOptions().cl_khr_fp16 == 0)
     return ImpCastExprToType(Res.get(), Context.FloatTy, CK_FloatingCast);
 
   // Try to perform integral promotions if the object has a theoretically
@@ -3220,7 +3220,10 @@ ExprResult Sema::ActOnNumericConstant(const Token &Tok, Scope *UDLScope) {
   if (Invalid)
     return ExprError();
 
-  NumericLiteralParser Literal(TokSpelling, Tok.getLocation(), PP);
+  llvm::APFloat::roundingMode Rounding = llvm::APFloat::rmNearestTiesToEven;
+  if (LangOpts.FloatConstRoundToZero)
+    Rounding = llvm::APFloat::rmTowardZero;
+  NumericLiteralParser Literal(TokSpelling, Tok.getLocation(), PP, Rounding);
   if (Literal.hadError)
     return ExprError();
 
@@ -3319,7 +3322,9 @@ ExprResult Sema::ActOnNumericConstant(const Token &Tok, Scope *UDLScope) {
 
   if (Literal.isFloatingLiteral()) {
     QualType Ty;
-    if (Literal.isFloat)
+    if (Literal.isHalf)
+      Ty = Context.HalfTy;
+    else if (Literal.isFloat)
       Ty = Context.FloatTy;
     else if (!Literal.isLong)
       Ty = Context.DoubleTy;
@@ -3331,9 +3336,7 @@ ExprResult Sema::ActOnNumericConstant(const Token &Tok, Scope *UDLScope) {
     if (Ty == Context.DoubleTy) {
       if (getLangOpts().SinglePrecisionConstants) {
         Res = ImpCastExprToType(Res, Context.FloatTy, CK_FloatingCast).get();
-      } else if (getLangOpts().OpenCL &&
-                 !((getLangOpts().OpenCLVersion >= 120) ||
-                   getOpenCLOptions().cl_khr_fp64)) {
+      } else if (getLangOpts().OpenCL && !getOpenCLOptions().cl_khr_fp64) {
         Diag(Tok.getLocation(), diag::warn_double_const_requires_fp64);
         Res = ImpCastExprToType(Res, Context.FloatTy, CK_FloatingCast).get();
       }
@@ -4448,6 +4451,23 @@ bool Sema::GatherArgumentsForCall(SourceLocation CallLoc, FunctionDecl *FDecl,
                               diag::err_call_incomplete_argument, Arg))
         return true;
 
+      // Allow (implicit) casting of 0 to event_t
+      if (!Arg->getType()->isEventT() && ProtoArgType->isEventT()) {
+        ImpCastExprToType(Arg, ProtoArgType, CK_NoOp);
+      }
+
+      // Allow (implicit) casting of pipe(type) to pipe void*
+      // %0 = bitcast i32* %shouldBePipe.addr to i8*
+      if (Arg->getType()->isPipeType() &&
+          ProtoArgType->isPointerType() && 
+          ProtoArgType->castAs<PointerType>()->getPointeeType()->isPipeType() &&
+          ProtoArgType->castAs<PointerType>()->getPointeeType()->castAs<PipeType>()->getValueType()->isVoidType()) {
+        Arg = new (Context) UnaryOperator(Arg, UO_AddrOf, 
+                                          Context.getPointerType(Arg->getType()),
+                                          VK_RValue, OK_Ordinary,
+                                          SourceLocation());
+      }
+
       // Strip the unbridged-cast placeholder expression off, if applicable.
       bool CFAudited = false;
       if (Arg->getType() == Context.ARCUnbridgedCastTy &&
@@ -6607,9 +6627,10 @@ checkPointerTypesForAssignment(Sema &S, QualType LHSType, QualType RHSType) {
   // incomplete type and the other is a pointer to a qualified or unqualified
   // version of void...
   if (lhptee->isVoidType()) {
-    if (rhptee->isIncompleteOrObjectType())
+    if (rhptee->isIncompleteOrObjectType() && !rhptee->isPipeType())
       return ConvTy;
-
+    else
+      return Sema::CompatiblePointerDiscardsQualifiers;
     // As an extension, we allow cast to/from void* to function pointer.
     assert(rhptee->isFunctionType());
     return Sema::FunctionVoidPointer;
@@ -6623,6 +6644,9 @@ checkPointerTypesForAssignment(Sema &S, QualType LHSType, QualType RHSType) {
     assert(lhptee->isFunctionType());
     return Sema::FunctionVoidPointer;
   }
+  
+  if (rhptee->isPipeType() && lhptee->isPipeType())
+    return ConvTy;
 
   // C99 6.5.16.1p1 (constraint 3): both operands are pointers to qualified or
   // unqualified versions of compatible types, ...
@@ -6803,6 +6827,11 @@ Sema::CheckAssignmentConstraints(QualType LHSType, ExprResult &RHS,
     return Compatible;
   }
 
+  // OpenCL sampler constructor, a special case
+  if (LHSType->isSamplerT()) {
+    if (RHSType->isIntegerType()) return Compatible;
+  }
+
   // If the left-hand side is a reference type, then we are in a
   // (rare!) case where we've allowed the use of references in C,
   // e.g., as a parameter type in a built-in function. In this case,
@@ -6821,8 +6850,6 @@ Sema::CheckAssignmentConstraints(QualType LHSType, ExprResult &RHS,
   // Allow scalar to ExtVector assignments, and assignments of an ExtVector type
   // to the same ExtVector type.
   if (LHSType->isExtVectorType()) {
-    if (RHSType->isExtVectorType())
-      return Incompatible;
     if (RHSType->isArithmeticType()) {
       // CK_VectorSplat does T -> vector T, so first cast to the
       // element type.
@@ -6834,6 +6861,20 @@ Sema::CheckAssignmentConstraints(QualType LHSType, ExprResult &RHS,
       Kind = CK_VectorSplat;
       return Compatible;
     }
+    if (RHSType->isExtVectorType()) {
+      if (LHSType == RHSType)
+        return Compatible;
+      else {
+        if ((LHSType->getAs<ExtVectorType>()->getElementType().getUnqualifiedType() ==
+             RHSType->getAs<ExtVectorType>()->getElementType().getUnqualifiedType()) &&
+            (LHSType->getAs<ExtVectorType>()->getNumElements() ==
+             RHSType->getAs<ExtVectorType>()->getNumElements()))
+            return Compatible;
+        else
+          return Incompatible;
+      }
+    }
+
   }
 
   // Conversions to or from vector type.
@@ -7166,6 +7207,14 @@ Sema::CheckSingleAssignmentConstraints(QualType LHSType, ExprResult &RHS,
     return Compatible;
   }
 
+  // OpenCL: The left operand is a OpenCL sampler or OpenCL image type
+  // and the right is a constant integer expression.
+  if ((LHSType->isSamplerT() || LHSType->isImageType() || LHSType->isEventT()) &&
+    RHS.get()->getType()->isIntegerType()) {
+    RHS = ImpCastExprToType(RHS.get(), LHSType, CK_BitCast);
+    return Compatible;
+  }
+
   // This check seems unnatural, however it is necessary to ensure the proper
   // conversion of functions/arrays. If the conversion were done for all
   // DeclExpr's (created by ActOnIdExpression), it would mess up the unary
@@ -10675,7 +10724,7 @@ ExprResult Sema::CreateBuiltinUnaryOp(SourceLocation OpLoc,
     resultType = Input.get()->getType();
 
     // Though we still have to promote half FP to float...
-    if (resultType->isHalfType() && !Context.getLangOpts().NativeHalfType) {
+    if (resultType->isHalfType() && getOpenCLOptions().cl_khr_fp16 == 0) {
       Input = ImpCastExprToType(Input.get(), Context.FloatTy, CK_FloatingCast).get();
       resultType = Context.FloatTy;
     }
@@ -12992,6 +13041,9 @@ bool Sema::tryCaptureVariable(
         case Type::Atomic:
           QTy = cast<AtomicType>(Ty)->getValueType();
           break;
+        case Type::Pipe:
+          QTy = cast<PipeType>(Ty)->getValueType();
+          break;
         }
       } while (!QTy.isNull() && QTy->isVariablyModifiedType());
     }
diff --git lib/Sema/SemaExprCXX.cpp lib/Sema/SemaExprCXX.cpp
index 01966d5..6d3d634 100644
--- a/tools/clang/lib/Sema/SemaExprCXX.cpp
+++ b/tools/clang/lib/Sema/SemaExprCXX.cpp
@@ -3425,6 +3425,16 @@ Sema::PerformImplicitConversion(Expr *From, QualType ToType,
                              From->getValueKind()).get();
     break;
 
+  case ICK_Pipe_Void_PTR_Conversion:
+	  From = new (Context) UnaryOperator(From, UO_AddrOf, 
+                                          Context.getPointerType(From->getType()),
+                                          VK_RValue, OK_Ordinary,
+                                          SourceLocation());
+  /*  From = ImpCastExprToType(From, ToType,
+                             CK_ZeroToOCLEvent,
+                             From->getValueKind()).get();*/
+    break;
+
   case ICK_Lvalue_To_Rvalue:
   case ICK_Array_To_Pointer:
   case ICK_Function_To_Pointer:
diff --git lib/Sema/SemaExprMember.cpp lib/Sema/SemaExprMember.cpp
index a9f1919..50c55f5 100644
--- a/tools/clang/lib/Sema/SemaExprMember.cpp
+++ b/tools/clang/lib/Sema/SemaExprMember.cpp
@@ -1689,7 +1689,8 @@ BuildFieldReferenceExpr(Sema &S, Expr *BaseExpr, bool IsArrow,
     Qualifiers MemberQuals
     = S.Context.getCanonicalType(MemberType).getQualifiers();
 
-    assert(!MemberQuals.hasAddressSpace());
+    //OpenCL allows struct members with address spaces
+    //assert(!MemberQuals.hasAddressSpace());
 
 
     Qualifiers Combined = BaseQuals + MemberQuals;
diff --git lib/Sema/SemaInit.cpp lib/Sema/SemaInit.cpp
index adec512..75c79a9 100644
--- a/tools/clang/lib/Sema/SemaInit.cpp
+++ b/tools/clang/lib/Sema/SemaInit.cpp
@@ -1104,7 +1104,7 @@ void InitListChecker::CheckSubElementType(const InitializedEntity &Entity,
     }
 
     // Fall through for subaggregate initialization
-  } else if (ElemType->isScalarType() || ElemType->isAtomicType()) {
+  } else if (ElemType->isScalarType() || ElemType->isAtomicType() || ElemType->isPipeType()) {
     // FIXME: Need to handle atomic aggregate types with implicit init lists.
     return CheckScalarType(Entity, IList, ElemType, Index,
                            StructuredList, StructuredIndex);
@@ -6615,6 +6615,12 @@ InitializationSequence::Perform(Sema &S,
         return ExprError();
       CurInit = CurInitExprRes;
 
+      // Allow conversion between "0" and event_t
+      if (ConvTy != Sema::Compatible &&
+          Entity.getKind() == InitializedEntity::EK_Parameter &&
+          SourceType->isLiteralType(S.Context) && Step->Type->isEventT())
+        ConvTy = Sema::Compatible;
+
       bool Complained;
       if (S.DiagnoseAssignmentResult(ConvTy, Kind.getLocation(),
                                      Step->Type, SourceType,
diff --git lib/Sema/SemaLookup.cpp lib/Sema/SemaLookup.cpp
index 2e7f891..4ca55fb 100644
--- a/tools/clang/lib/Sema/SemaLookup.cpp
+++ b/tools/clang/lib/Sema/SemaLookup.cpp
@@ -2441,6 +2441,9 @@ addAssociatedClassesAndNamespaces(AssociatedLookup &Result, QualType Ty) {
     case Type::Atomic:
       T = cast<AtomicType>(T)->getValueType().getTypePtr();
       continue;
+    case Type::Pipe:
+      T = cast<PipeType>(T)->getValueType().getTypePtr();
+      continue;
     }
 
     if (Queue.empty())
diff --git lib/Sema/SemaOverload.cpp lib/Sema/SemaOverload.cpp
index 31f581d..0a6bebf 100644
--- a/tools/clang/lib/Sema/SemaOverload.cpp
+++ b/tools/clang/lib/Sema/SemaOverload.cpp
@@ -1478,6 +1478,7 @@ static bool IsStandardConversion(Sema &S, Expr* From, QualType ToType,
   //   A glvalue (3.10) of a non-function, non-array type T can
   //   be converted to a prvalue.
   bool argIsLValue = From->isGLValue();
+  llvm::APSInt resVal;
   if (argIsLValue &&
       !FromType->isFunctionType() && !FromType->isArrayType() &&
       S.Context.getCanonicalType(FromType) != S.Context.OverloadTy) {
@@ -1517,6 +1518,11 @@ static bool IsStandardConversion(Sema &S, Expr* From, QualType ToType,
       SCS.setAllToTypes(FromType);
       return true;
     }
+  } else if (FromType->isLiteralType(S.getASTContext()) && FromType->isIntegerType() && ToType->isEventT() &&
+             (From->EvaluateAsInt(resVal, S.getASTContext()) == true) && resVal == 0) {
+    /* OpenCL conversion from 0 integer to null event_t */
+    SCS.First = ICK_Compatible_Conversion;
+    FromType = ToType;	
   } else if (FromType->isFunctionType() && argIsLValue) {
     // Function-to-pointer conversion (C++ 4.3).
     SCS.First = ICK_Function_To_Pointer;
@@ -1630,6 +1636,12 @@ static bool IsStandardConversion(Sema &S, Expr* From, QualType ToType,
              (From->EvaluateKnownConstInt(S.getASTContext()) == 0)) {
     SCS.Second = ICK_Zero_Event_Conversion;
     FromType = ToType;
+  } else if (FromType->isPipeType() && 
+             ToType->isPointerType() &&
+             ToType->castAs<PointerType>()->getPointeeType()->isPipeType() &&
+             ToType->castAs<PointerType>()->getPointeeType()->castAs<PipeType>()->getValueType()->isVoidType()) {
+    SCS.Second = ICK_Pipe_Void_PTR_Conversion;
+    FromType = ToType;
   } else {
     // No second conversion required.
     SCS.Second = ICK_Identity;
@@ -3683,10 +3695,33 @@ CompareQualificationConversions(Sema &S,
     // to unwrap. This essentially mimics what
     // IsQualificationConversion does, but here we're checking for a
     // strict subset of qualifiers.
-    if (T1.getCVRQualifiers() == T2.getCVRQualifiers())
-      // The qualifiers are the same, so this doesn't tell us anything
-      // about how the sequences rank.
-      ;
+    if (T1.getCVRQualifiers() == T2.getCVRQualifiers()) {
+      // The qualifiers are the same.
+      // We may still be able to rank them according to
+      // address space differences
+      unsigned T1AS = T1.getAddressSpace();
+      unsigned T2AS = T2.getAddressSpace();
+      if (T1AS != T2AS) {
+        // Whichever one does not perform conversion is better
+        QualType ST1 = SCS1.getToType(1);
+        QualType ST2 = SCS2.getToType(1);
+        if (S.Context.UnwrapSimilarPointerTypes(ST1, ST2)) {
+          unsigned ST1AS = ST1.getAddressSpace();
+          unsigned ST2AS = ST2.getAddressSpace();
+          // Check if we are converting from the default AS
+          unsigned defAS = S.getLangOpts().OpenCLVersion < 200 ?
+            LangAS::opencl_private : LangAS::opencl_generic;
+          T1AS = T1AS == 0 ? defAS : T1AS;
+          T2AS = T2AS == 0 ? defAS : T2AS;
+          ST1AS = ST1AS == 0 ? defAS : ST1AS;
+          ST2AS = ST2AS == 0 ? defAS : ST2AS;
+          if (T1AS == ST1AS && T2AS != ST2AS)
+            Result = ImplicitConversionSequence::Better;
+          else if (T1AS != ST1AS && T2AS == ST2AS)
+            Result = ImplicitConversionSequence::Worse;
+        }
+      }
+    }
     else if (T2.isMoreQualifiedThan(T1)) {
       // T1 has fewer qualifiers, so it could be the better sequence.
       if (Result == ImplicitConversionSequence::Worse)
@@ -4969,6 +5004,7 @@ static bool CheckConvertedConstantConversions(Sema &S,
   case ICK_TransparentUnionConversion:
   case ICK_Writeback_Conversion:
   case ICK_Zero_Event_Conversion:
+  case ICK_Pipe_Void_PTR_Conversion:
     return false;
 
   case ICK_Lvalue_To_Rvalue:
diff --git lib/Sema/SemaStmtAttr.cpp lib/Sema/SemaStmtAttr.cpp
index 5b71c11..c99a7f6 100644
--- a/tools/clang/lib/Sema/SemaStmtAttr.cpp
+++ b/tools/clang/lib/Sema/SemaStmtAttr.cpp
@@ -204,6 +204,8 @@ static Attr *ProcessStmtAttribute(Sema &S, Stmt *St, const AttributeList &A,
     return handleFallThroughAttr(S, St, A, Range);
   case AttributeList::AT_LoopHint:
     return handleLoopHintAttr(S, St, A, Range);
+  case clang::AttributeList::AT_OpenCLUnrollHint:
+	  return nullptr;
   default:
     // if we're here, then we parsed a known attribute, but didn't recognize
     // it as a statement attribute => it is declaration attribute
diff --git lib/Sema/SemaTemplate.cpp lib/Sema/SemaTemplate.cpp
index 035c37c..f766fb7 100644
--- a/tools/clang/lib/Sema/SemaTemplate.cpp
+++ b/tools/clang/lib/Sema/SemaTemplate.cpp
@@ -4147,6 +4147,10 @@ bool UnnamedLocalNoLinkageFinder::VisitAtomicType(const AtomicType* T) {
   return Visit(T->getValueType());
 }
 
+bool UnnamedLocalNoLinkageFinder::VisitPipeType(const PipeType* T) {
+  return Visit(T->getValueType());
+}
+
 bool UnnamedLocalNoLinkageFinder::VisitTagDecl(const TagDecl *Tag) {
   if (Tag->getDeclContext()->isFunctionOrMethod()) {
     S.Diag(SR.getBegin(),
diff --git lib/Sema/SemaTemplateDeduction.cpp lib/Sema/SemaTemplateDeduction.cpp
index ae8157e..ba7bc5b 100644
--- a/tools/clang/lib/Sema/SemaTemplateDeduction.cpp
+++ b/tools/clang/lib/Sema/SemaTemplateDeduction.cpp
@@ -1244,6 +1244,15 @@ DeduceTemplateArgumentsByTypeMatch(Sema &S,
 
       return Sema::TDK_NonDeducedMismatch;
 
+    case Type::Pipe:
+      if (const PipeType *PipeArg = Arg->getAs<PipeType>())
+        return DeduceTemplateArgumentsByTypeMatch(S, TemplateParams,
+                                       cast<PipeType>(Param)->getValueType(),
+                                       PipeArg->getValueType(),
+                                       Info, Deduced, TDF);
+
+      return Sema::TDK_NonDeducedMismatch;
+
     //     T *
     case Type::Pointer: {
       QualType PointeeType;
diff --git lib/Sema/SemaTemplateVariadic.cpp lib/Sema/SemaTemplateVariadic.cpp
index fd3ba35..df01c3e 100644
--- a/tools/clang/lib/Sema/SemaTemplateVariadic.cpp
+++ b/tools/clang/lib/Sema/SemaTemplateVariadic.cpp
@@ -702,7 +702,8 @@ bool Sema::containsUnexpandedParameterPacks(Declarator &D) {
   case TST_typename:
   case TST_typeofType:
   case TST_underlyingType:
-  case TST_atomic: {
+  case TST_atomic:
+  case TST_pipe: {
     QualType T = DS.getRepAsType().get();
     if (!T.isNull() && T->containsUnexpandedParameterPack())
       return true;
diff --git lib/Sema/SemaType.cpp lib/Sema/SemaType.cpp
index 02a31ef..f788716 100644
--- a/tools/clang/lib/Sema/SemaType.cpp
+++ b/tools/clang/lib/Sema/SemaType.cpp
@@ -726,7 +726,8 @@ static void diagnoseAndRemoveTypeQualifiers(Sema &S, const DeclSpec &DS,
   typedef std::pair<DeclSpec::TQ, SourceLocation> QualLoc;
   for (QualLoc Qual : {QualLoc(DeclSpec::TQ_const, DS.getConstSpecLoc()),
                        QualLoc(DeclSpec::TQ_volatile, DS.getVolatileSpecLoc()),
-                       QualLoc(DeclSpec::TQ_atomic, DS.getAtomicSpecLoc())}) {
+                       QualLoc(DeclSpec::TQ_atomic, DS.getAtomicSpecLoc()),
+                       QualLoc(DeclSpec::TQ_pipe, DS.getPipeSpecLoc())}) {
     if (!(RemoveTQs & Qual.first))
       continue;
 
@@ -1325,9 +1326,7 @@ static QualType ConvertDeclSpecToType(TypeProcessingState &state) {
     else
       Result = Context.DoubleTy;
 
-    if (S.getLangOpts().OpenCL &&
-        !((S.getLangOpts().OpenCLVersion >= 120) ||
-          S.getOpenCLOptions().cl_khr_fp64)) {
+    if (S.getLangOpts().OpenCL && !S.getOpenCLOptions().cl_khr_fp64) {
       S.Diag(DS.getTypeSpecTypeLoc(), diag::err_type_requires_extension)
           << Result << "cl_khr_fp64";
       declarator.setInvalidType(true);
@@ -1506,6 +1505,16 @@ static QualType ConvertDeclSpecToType(TypeProcessingState &state) {
     }
     break;
 
+  case DeclSpec::TST_pipe:
+    Result = S.GetTypeFromParser(DS.getRepAsType());
+    assert(!Result.isNull() && "Didn't get a type for pipe?");
+    Result = S.BuildPipeType(Result, DS.getTypeSpecTypeLoc());
+    if (Result.isNull()) {
+      Result = Context.IntTy;
+      declarator.setInvalidType(true);
+    }
+    break;
+
   case DeclSpec::TST_error:
     Result = Context.IntTy;
     declarator.setInvalidType(true);
@@ -1574,7 +1583,7 @@ static QualType ConvertDeclSpecToType(TypeProcessingState &state) {
     if (TypeQuals && Result->isReferenceType()) {
       diagnoseAndRemoveTypeQualifiers(
           S, DS, TypeQuals, Result,
-          DeclSpec::TQ_const | DeclSpec::TQ_volatile | DeclSpec::TQ_atomic,
+          DeclSpec::TQ_const | DeclSpec::TQ_volatile | DeclSpec::TQ_atomic | DeclSpec::TQ_pipe,
           diag::warn_typecheck_reference_qualifiers);
     }
 
@@ -1664,7 +1673,7 @@ QualType Sema::BuildQualifiedType(QualType T, SourceLocation Loc,
     return QualType();
 
   // Convert from DeclSpec::TQ to Qualifiers::TQ by just dropping TQ_atomic.
-  unsigned CVR = CVRA & ~DeclSpec::TQ_atomic;
+  unsigned CVR = CVRA & ~DeclSpec::TQ_atomic & ~DeclSpec::TQ_pipe;
 
   // C11 6.7.3/5:
   //   If the same qualifier appears more than once in the same
@@ -1691,6 +1700,22 @@ QualType Sema::BuildQualifiedType(QualType T, SourceLocation Loc,
     return BuildQualifiedType(T, Loc, Split.Quals);
   }
 
+  if (CVRA & DeclSpec::TQ_pipe && !T->isPipeType()) {
+    //   If other qualifiers appear along with the pipe qualifier in a
+    //   specifier-qualifier-list, the resulting type is the so-qualified
+    //   pipe type.
+    //
+    // Don't need to worry about array types here, since pipe can't be
+    // applied to such types.
+    SplitQualType Split = T.getSplitUnqualifiedType();
+    T = BuildPipeType(QualType(Split.Ty, 0),
+                        DS ? DS->getPipeSpecLoc() : Loc);
+    if (T.isNull())
+      return T;
+    Split.Quals.addCVRQualifiers(CVR);
+    return BuildQualifiedType(T, Loc, Split.Quals);
+  }
+
   return BuildQualifiedType(T, Loc, Qualifiers::fromCVRMask(CVR), DS);
 }
 
@@ -1835,6 +1860,11 @@ QualType Sema::BuildPointerType(QualType T,
   if (getLangOpts().ObjCAutoRefCount)
     T = inferARCLifetimeForPointee(*this, T, Loc, /*reference*/ false);
 
+  if (getLangOpts().OpenCLVersion >= 200 && T.getAddressSpace() == 0) {
+    // In CL2.0, the default address space is the generic
+    T = Context.getAddrSpaceQualType(T, LangAS::opencl_generic);
+  }
+
   // Build the pointer type.
   return Context.getPointerType(T);
 }
@@ -2427,7 +2457,8 @@ void Sema::diagnoseIgnoredQualifiers(unsigned DiagID, unsigned Quals,
                                      SourceLocation ConstQualLoc,
                                      SourceLocation VolatileQualLoc,
                                      SourceLocation RestrictQualLoc,
-                                     SourceLocation AtomicQualLoc) {
+                                     SourceLocation AtomicQualLoc,
+                                     SourceLocation PipeQualLoc) {
   if (!Quals)
     return;
 
@@ -2435,20 +2466,21 @@ void Sema::diagnoseIgnoredQualifiers(unsigned DiagID, unsigned Quals,
     unsigned Mask;
     const char *Name;
     SourceLocation Loc;
-  } const QualKinds[4] = {
+  } const QualKinds[5] = {
     { DeclSpec::TQ_const, "const", ConstQualLoc },
     { DeclSpec::TQ_volatile, "volatile", VolatileQualLoc },
     { DeclSpec::TQ_restrict, "restrict", RestrictQualLoc },
-    { DeclSpec::TQ_atomic, "_Atomic", AtomicQualLoc }
+    { DeclSpec::TQ_atomic, "_Atomic", AtomicQualLoc },
+    { DeclSpec::TQ_pipe, "pipe", PipeQualLoc }
   };
 
   SmallString<32> QualStr;
   unsigned NumQuals = 0;
   SourceLocation Loc;
-  FixItHint FixIts[4];
+  FixItHint FixIts[5];
 
   // Build a string naming the redundant qualifiers.
-  for (unsigned I = 0; I != 4; ++I) {
+  for (unsigned I = 0; I != 5; ++I) {
     if (Quals & QualKinds[I].Mask) {
       if (!QualStr.empty()) QualStr += ' ';
       QualStr += QualKinds[I].Name;
@@ -2467,7 +2499,7 @@ void Sema::diagnoseIgnoredQualifiers(unsigned DiagID, unsigned Quals,
   }
 
   Diag(Loc.isInvalid() ? FallbackLoc : Loc, DiagID)
-    << QualStr << NumQuals << FixIts[0] << FixIts[1] << FixIts[2] << FixIts[3];
+    << QualStr << NumQuals << FixIts[0] << FixIts[1] << FixIts[2] << FixIts[3] << FixIts[4];
 }
 
 // Diagnose pointless type qualifiers on the return type of a function.
@@ -2500,7 +2532,8 @@ static void diagnoseRedundantReturnTypeQualifiers(Sema &S, QualType RetTy,
           SourceLocation::getFromRawEncoding(PTI.ConstQualLoc),
           SourceLocation::getFromRawEncoding(PTI.VolatileQualLoc),
           SourceLocation::getFromRawEncoding(PTI.RestrictQualLoc),
-          SourceLocation::getFromRawEncoding(PTI.AtomicQualLoc));
+          SourceLocation::getFromRawEncoding(PTI.AtomicQualLoc),
+          SourceLocation::getFromRawEncoding(PTI.PipeQualLoc));
       return;
     }
 
@@ -2535,7 +2568,8 @@ static void diagnoseRedundantReturnTypeQualifiers(Sema &S, QualType RetTy,
                               D.getDeclSpec().getConstSpecLoc(),
                               D.getDeclSpec().getVolatileSpecLoc(),
                               D.getDeclSpec().getRestrictSpecLoc(),
-                              D.getDeclSpec().getAtomicSpecLoc());
+                              D.getDeclSpec().getAtomicSpecLoc(),
+                              D.getDeclSpec().getPipeSpecLoc());
 }
 
 static QualType GetDeclSpecTypeForDeclarator(TypeProcessingState &state,
@@ -4640,6 +4674,25 @@ namespace {
       }
     }
 
+    void VisitPipeTypeLoc(PipeTypeLoc TL) {
+      // A PipeTypeLoc can come from either an pipe(...) type specifier
+      // or an pipe qualifier.
+      if (DS.getTypeSpecType() == DeclSpec::TST_pipe) {
+        TL.setKWLoc(DS.getTypeSpecTypeLoc());
+        TL.setParensRange(DS.getTypeofParensRange());
+
+        TypeSourceInfo *TInfo = nullptr;
+        Sema::GetTypeFromParser(DS.getRepAsType(), &TInfo);
+        assert(TInfo);
+        TL.getValueLoc().initializeFullCopy(TInfo->getTypeLoc());
+      } else {
+        TL.setKWLoc(DS.getPipeSpecLoc());
+        // No parens, to indicate this was spelled as an pipe qualifier.
+        TL.setParensRange(SourceRange());
+        Visit(TL.getValueLoc());
+      }
+    }
+
     void VisitTypeLoc(TypeLoc TL) {
       // FIXME: add other typespec types and change this to an assert.
       TL.initialize(Context, DS.getTypeSpecTypeLoc());
@@ -4790,6 +4843,29 @@ static void fillAtomicQualLoc(AtomicTypeLoc ATL, const DeclaratorChunk &Chunk) {
   ATL.setParensRange(SourceRange());
 }
 
+static void fillPipeQualLoc(PipeTypeLoc ATL, const DeclaratorChunk &Chunk) {
+  SourceLocation Loc;
+  switch (Chunk.Kind) {
+  case DeclaratorChunk::Function:
+  case DeclaratorChunk::Array:
+  case DeclaratorChunk::Paren:
+    llvm_unreachable("cannot be pipe qualified");
+
+  case DeclaratorChunk::Pointer:
+    Loc = SourceLocation::getFromRawEncoding(Chunk.Ptr.PipeQualLoc);
+    break;
+
+  case DeclaratorChunk::BlockPointer:
+  case DeclaratorChunk::Reference:
+  case DeclaratorChunk::MemberPointer:
+    // FIXME: Provide a source location for the pipe keyword.
+    break;
+  }
+
+  ATL.setKWLoc(Loc);
+  ATL.setParensRange(SourceRange());
+}
+
 /// \brief Create and instantiate a TypeSourceInfo with type source information.
 ///
 /// \param T QualType referring to the type as written in source code.
@@ -4819,6 +4895,11 @@ Sema::GetTypeSourceInfoForDeclarator(Declarator &D, QualType T,
       CurrTL = ATL.getValueLoc().getUnqualifiedLoc();
     }
 
+    if (PipeTypeLoc ATL = CurrTL.getAs<PipeTypeLoc>()) {
+      fillPipeQualLoc(ATL, D.getTypeObject(i));
+      CurrTL = ATL.getValueLoc().getUnqualifiedLoc();
+    }
+
     while (AttributedTypeLoc TL = CurrTL.getAs<AttributedTypeLoc>()) {
       fillAttributedTypeLoc(TL, D.getTypeObject(i).getAttrs(), DeclAttrs);
       CurrTL = TL.getNextTypeLoc().getUnqualifiedLoc();
@@ -4978,8 +5059,9 @@ static void HandleAddressSpaceTypeAttribute(QualType &Type,
       ASIdx = LangAS::opencl_constant; break;
     case AttributeList::AT_OpenCLGenericAddressSpace:
       ASIdx = LangAS::opencl_generic; break;
+    case AttributeList::AT_OpenCLPrivateAddressSpace:
+      ASIdx = LangAS::opencl_private; break;
     default:
-      assert(Attr.getKind() == AttributeList::AT_OpenCLPrivateAddressSpace);
       ASIdx = 0; break;
     }
   }
@@ -6891,3 +6973,34 @@ QualType Sema::BuildAtomicType(QualType T, SourceLocation Loc) {
   // Build the pointer type.
   return Context.getAtomicType(T);
 }
+
+QualType Sema::BuildPipeType(QualType T, SourceLocation Loc) {
+  if (!T->isDependentType()) {
+    int DisallowedKind = -1;
+    if (T->isArrayType())
+      DisallowedKind = 1;
+    else if (T->isFunctionType())
+      DisallowedKind = 2;
+    else if (T->isReferenceType())
+      DisallowedKind = 3;
+    else if (T->isAtomicType())
+      DisallowedKind = 4;
+    else if (T->isPipeType())
+      DisallowedKind = 5;
+    else if (T.hasQualifiers())
+      DisallowedKind = 6;
+    else if (false)
+      // Some other non-trivially-copyable type (probably a C++ class)
+      DisallowedKind = 7;
+
+    if (DisallowedKind != -1) {
+      Diag(Loc, diag::err_pipe_specifier_bad_type) << DisallowedKind << T;
+      return QualType();
+    }
+
+    // FIXME: Do we need any handling for ARC here?
+  }
+
+  // Build the pointer type.
+  return Context.getPipeType(T);
+}
diff --git lib/Sema/TreeTransform.h lib/Sema/TreeTransform.h
index 6e193a3..812ff2a 100644
--- a/tools/clang/lib/Sema/TreeTransform.h
+++ b/tools/clang/lib/Sema/TreeTransform.h
@@ -5170,6 +5170,23 @@ QualType TreeTransform<Derived>::TransformAtomicType(TypeLocBuilder &TLB,
   return Result;
 }
 
+template<typename Derived>
+QualType TreeTransform<Derived>::TransformPipeType(TypeLocBuilder &TLB,
+                                                     PipeTypeLoc TL) {
+  QualType ValueType = getDerived().TransformType(TLB, TL.getValueLoc());
+  if (ValueType.isNull())
+    return QualType();
+
+  QualType Result = TL.getType();
+
+  PipeTypeLoc NewTL = TLB.push<PipeTypeLoc>(Result);
+  NewTL.setKWLoc(TL.getKWLoc());
+  NewTL.setLParenLoc(TL.getLParenLoc());
+  NewTL.setRParenLoc(TL.getRParenLoc());
+
+  return Result;
+}
+
   /// \brief Simple iterator that traverses the template arguments in a
   /// container that provides a \c getArgLoc() member function.
   ///
diff --git lib/Serialization/ASTCommon.cpp lib/Serialization/ASTCommon.cpp
index b1bf4a6..12811fb 100644
--- a/tools/clang/lib/Serialization/ASTCommon.cpp
+++ b/tools/clang/lib/Serialization/ASTCommon.cpp
@@ -67,9 +67,19 @@ serialization::TypeIdxFromBuiltin(const BuiltinType *BT) {
   case BuiltinType::OCLImage1dBuffer: ID = PREDEF_TYPE_IMAGE1D_BUFF_ID; break;
   case BuiltinType::OCLImage2d:       ID = PREDEF_TYPE_IMAGE2D_ID;      break;
   case BuiltinType::OCLImage2dArray:  ID = PREDEF_TYPE_IMAGE2D_ARR_ID;  break;
+  case BuiltinType::OCLImage2dDepth:  ID = PREDEF_TYPE_IMAGE2D_DEP_ID;  break;
+  case BuiltinType::OCLImage2dArrayDepth: ID = PREDEF_TYPE_IMAGE2D_ARR_DEP_ID; break;
+  case BuiltinType::OCLImage2dMSAA:   ID = PREDEF_TYPE_IMAGE2D_MSAA_ID; break;
+  case BuiltinType::OCLImage2dArrayMSAA: ID = PREDEF_TYPE_IMAGE2D_ARR_MSAA_ID; break;
+  case BuiltinType::OCLImage2dMSAADepth: ID = PREDEF_TYPE_IMAGE2D_MSAA_DEP_ID; break;
+  case BuiltinType::OCLImage2dArrayMSAADepth: ID = PREDEF_TYPE_IMAGE2D_ARR_MSAA_DEPTH_ID; break;
   case BuiltinType::OCLImage3d:       ID = PREDEF_TYPE_IMAGE3D_ID;      break;
   case BuiltinType::OCLSampler:       ID = PREDEF_TYPE_SAMPLER_ID;      break;
   case BuiltinType::OCLEvent:         ID = PREDEF_TYPE_EVENT_ID;        break;
+  case BuiltinType::OCLClkEvent:      ID = PREDEF_TYPE_CLK_EVENT_ID;    break;
+  case BuiltinType::OCLQueue:         ID = PREDEF_TYPE_QUEUE_ID;        break;
+  case BuiltinType::OCLNDRange:       ID = PREDEF_TYPE_NDRANGE_ID;      break;
+  case BuiltinType::OCLReserveID:     ID = PREDEF_TYPE_RESERVE_ID_ID;   break;
   case BuiltinType::BuiltinFn:
                                 ID = PREDEF_TYPE_BUILTIN_FN; break;
 
diff --git lib/Serialization/ASTReader.cpp lib/Serialization/ASTReader.cpp
index 9fbf55b..4e69f5b 100644
--- a/tools/clang/lib/Serialization/ASTReader.cpp
+++ b/tools/clang/lib/Serialization/ASTReader.cpp
@@ -1924,7 +1924,7 @@ InputFile ASTReader::getInputFile(ModuleFile &F, unsigned ID, bool Complain) {
   }
 
   if (File == nullptr) {
-    if (Complain) {
+    if (false) { // This would expose the PCH source path
       std::string ErrorStr = "could not find file '";
       ErrorStr += Filename;
       ErrorStr += "' referenced by AST file";
@@ -5399,6 +5399,14 @@ QualType ASTReader::readTypeRecord(unsigned Index) {
     QualType ValueType = readType(*Loc.F, Record, Idx);
     return Context.getAtomicType(ValueType);
   }
+  case TYPE_PIPE: {
+    if (Record.size() != 1) {
+      Error("Incorrect encoding of pipe type");
+      return QualType();
+    }
+    QualType ValueType = readType(*Loc.F, Record, Idx);
+    return Context.getPipeType(ValueType);
+  }
   }
   llvm_unreachable("Invalid TypeCode!");
 }
@@ -5670,6 +5678,11 @@ void TypeLocReader::VisitAtomicTypeLoc(AtomicTypeLoc TL) {
   TL.setLParenLoc(ReadSourceLocation(Record, Idx));
   TL.setRParenLoc(ReadSourceLocation(Record, Idx));
 }
+void TypeLocReader::VisitPipeTypeLoc(PipeTypeLoc TL) {
+  TL.setKWLoc(ReadSourceLocation(Record, Idx));
+  TL.setLParenLoc(ReadSourceLocation(Record, Idx));
+  TL.setRParenLoc(ReadSourceLocation(Record, Idx));
+}
 
 TypeSourceInfo *ASTReader::GetTypeSourceInfo(ModuleFile &F,
                                              const RecordData &Record,
@@ -5735,9 +5748,19 @@ QualType ASTReader::GetType(TypeID ID) {
     case PREDEF_TYPE_IMAGE1D_BUFF_ID: T = Context.OCLImage1dBufferTy; break;
     case PREDEF_TYPE_IMAGE2D_ID:    T = Context.OCLImage2dTy;       break;
     case PREDEF_TYPE_IMAGE2D_ARR_ID: T = Context.OCLImage2dArrayTy; break;
+    case PREDEF_TYPE_IMAGE2D_DEP_ID: T = Context.OCLImage2dDepthTy; break;
+    case PREDEF_TYPE_IMAGE2D_ARR_DEP_ID: T = Context.OCLImage2dArrayDepthTy; break;
+    case PREDEF_TYPE_IMAGE2D_MSAA_ID: T = Context.OCLImage2dMSAATy; break;
+    case PREDEF_TYPE_IMAGE2D_ARR_MSAA_ID: T = Context.OCLImage2dArrayMSAATy; break;
+    case PREDEF_TYPE_IMAGE2D_MSAA_DEP_ID: T = Context.OCLImage2dMSAADepthTy; break;
+    case PREDEF_TYPE_IMAGE2D_ARR_MSAA_DEPTH_ID: T = Context.OCLImage2dArrayMSAADepthTy; break;
     case PREDEF_TYPE_IMAGE3D_ID:    T = Context.OCLImage3dTy;       break;
     case PREDEF_TYPE_SAMPLER_ID:    T = Context.OCLSamplerTy;       break;
     case PREDEF_TYPE_EVENT_ID:      T = Context.OCLEventTy;         break;
+    case PREDEF_TYPE_CLK_EVENT_ID:  T = Context.OCLClkEventTy;      break;
+    case PREDEF_TYPE_QUEUE_ID:      T = Context.OCLQueueTy;         break;
+    case PREDEF_TYPE_NDRANGE_ID:    T = Context.OCLNDRangeTy;       break;
+    case PREDEF_TYPE_RESERVE_ID_ID: T = Context.OCLReserveIDTy;     break;
     case PREDEF_TYPE_AUTO_DEDUCT:   T = Context.getAutoDeductType(); break;
         
     case PREDEF_TYPE_AUTO_RREF_DEDUCT: 
diff --git lib/Serialization/ASTWriter.cpp lib/Serialization/ASTWriter.cpp
index 8b68638..ec088f6 100644
--- a/tools/clang/lib/Serialization/ASTWriter.cpp
+++ b/tools/clang/lib/Serialization/ASTWriter.cpp
@@ -443,6 +443,12 @@ ASTTypeWriter::VisitAtomicType(const AtomicType *T) {
   Code = TYPE_ATOMIC;
 }
 
+void
+ASTTypeWriter::VisitPipeType(const PipeType *T) {
+  Writer.AddTypeRef(T->getValueType(), Record);
+  Code = TYPE_PIPE;
+}
+
 namespace {
 
 class TypeLocWriter : public TypeLocVisitor<TypeLocWriter> {
@@ -670,6 +676,12 @@ void TypeLocWriter::VisitAtomicTypeLoc(AtomicTypeLoc TL) {
   Writer.AddSourceLocation(TL.getRParenLoc(), Record);
 }
 
+void TypeLocWriter::VisitPipeTypeLoc(PipeTypeLoc TL) {
+  Writer.AddSourceLocation(TL.getKWLoc(), Record);
+  Writer.AddSourceLocation(TL.getLParenLoc(), Record);
+  Writer.AddSourceLocation(TL.getRParenLoc(), Record);
+}
+
 void ASTWriter::WriteTypeAbbrevs() {
   using namespace llvm;
 
@@ -996,6 +1008,7 @@ void ASTWriter::WriteBlockInfoBlock() {
   RECORD(TYPE_AUTO);
   RECORD(TYPE_UNARY_TRANSFORM);
   RECORD(TYPE_ATOMIC);
+  RECORD(TYPE_PIPE);
   RECORD(TYPE_DECAYED);
   RECORD(TYPE_ADJUSTED);
   RECORD(DECL_TYPEDEF);
diff --git test/CodeGenOpenCL/relaxed-fpmath.cl test/CodeGenOpenCL/relaxed-fpmath.cl
index 6f302b1..4222ea9 100644
--- a/tools/clang/test/CodeGenOpenCL/relaxed-fpmath.cl
+++ b/tools/clang/test/CodeGenOpenCL/relaxed-fpmath.cl
@@ -2,6 +2,7 @@
 // RUN: %clang_cc1 %s -emit-llvm -cl-fast-relaxed-math -o - | FileCheck %s -check-prefix=FAST
 // RUN: %clang_cc1 %s -emit-llvm -cl-finite-math-only -o - | FileCheck %s -check-prefix=FINITE
 // RUN: %clang_cc1 %s -emit-llvm -cl-unsafe-math-optimizations -o - | FileCheck %s -check-prefix=UNSAFE
+// RUN: %clang_cc1 %s -emit-llvm -cl-no-signed-zeros -o - | FileCheck %s -check-prefix=NOSZ
 
 typedef __attribute__(( ext_vector_type(4) )) float float4;
 
@@ -12,6 +13,7 @@ float spscalardiv(float a, float b) {
   // FAST: fdiv fast float
   // FINITE: fdiv nnan ninf float
   // UNSAFE: fdiv nnan float
+  // NOSZ: fdiv nsz float
   return a / b;
 }
 // CHECK: attributes
diff --git test/SemaOpenCL/extension-fp64-cl1.1.cl test/SemaOpenCL/extension-fp64-cl1.1.cl
deleted file mode 100644
index 7e852ae..0000000
--- a/tools/clang/test/SemaOpenCL/extension-fp64-cl1.1.cl
+++ /dev/null
@@ -1,19 +0,0 @@
-// RUN: %clang_cc1 %s -verify -pedantic -fsyntax-only -cl-std=CL1.1
-
-void f1(double da) { // expected-error {{type 'double' requires cl_khr_fp64 extension}}
-  double d; // expected-error {{type 'double' requires cl_khr_fp64 extension}}
-  (void) 1.0; // expected-warning {{double precision constant requires cl_khr_fp64}}
-}
-
-#pragma OPENCL EXTENSION cl_khr_fp64 : enable
-
-void f2(void) {
-  double d;
-  (void) 1.0;
-}
-
-#pragma OPENCL EXTENSION cl_khr_fp64 : disable
-
-void f3(void) {
-  double d; // expected-error {{type 'double' requires cl_khr_fp64 extension}}
-}
diff --git test/SemaOpenCL/optional-core-fp64-cl1.2.cl test/SemaOpenCL/optional-core-fp64-cl1.2.cl
deleted file mode 100644
index e0f7f1d..0000000
--- a/tools/clang/test/SemaOpenCL/optional-core-fp64-cl1.2.cl
+++ /dev/null
@@ -1,20 +0,0 @@
-// RUN: %clang_cc1 %s -verify -pedantic -fsyntax-only -cl-std=CL1.2
-// expected-no-diagnostics
-
-void f1(double da) {
-  double d;
-  (void) 1.0;
-}
-
-#pragma OPENCL EXTENSION cl_khr_fp64 : enable
-
-void f2(void) {
-  double d;
-  (void) 1.0;
-}
-
-#pragma OPENCL EXTENSION cl_khr_fp64 : disable
-
-void f3(void) {
-  double d;
-}
diff --git test/SemaOpenCL/optional-core-fp64-cl2.0.cl test/SemaOpenCL/optional-core-fp64-cl2.0.cl
deleted file mode 100644
index 832529d..0000000
--- a/tools/clang/test/SemaOpenCL/optional-core-fp64-cl2.0.cl
+++ /dev/null
@@ -1,20 +0,0 @@
-// RUN: %clang_cc1 %s -verify -pedantic -fsyntax-only -cl-std=CL2.0
-// expected-no-diagnostics
-
-void f1(double da) {
-  double d;
-  (void) 1.0;
-}
-
-#pragma OPENCL EXTENSION cl_khr_fp64 : enable
-
-void f2(void) {
-  double d;
-  (void) 1.0;
-}
-
-#pragma OPENCL EXTENSION cl_khr_fp64 : disable
-
-void f3(void) {
-  double d;
-}
diff --git tools/libclang/CIndex.cpp tools/libclang/CIndex.cpp
index 8225a6c..20c0d7b 100644
--- a/tools/clang/tools/libclang/CIndex.cpp
+++ b/tools/clang/tools/libclang/CIndex.cpp
@@ -1682,6 +1682,10 @@ bool CursorVisitor::VisitAtomicTypeLoc(AtomicTypeLoc TL) {
   return Visit(TL.getValueLoc());
 }
 
+bool CursorVisitor::VisitPipeTypeLoc(PipeTypeLoc TL) {
+  return Visit(TL.getValueLoc());
+}
+
 #define DEFAULT_TYPELOC_IMPL(CLASS, PARENT) \
 bool CursorVisitor::Visit##CLASS##TypeLoc(CLASS##TypeLoc TL) { \
   return Visit##PARENT##Loc(TL); \
